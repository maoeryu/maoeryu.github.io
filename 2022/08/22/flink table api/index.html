<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"maoeryu.github.io","root":"/","images":"/images","scheme":"Pisces","version":"8.2.1","exturl":false,"sidebar":{"position":"left","width":200,"display":"post","padding":7,"offset":5},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>
<meta name="description" content="Apache Flink 有两种关系型 API 来做流批统一处理:Table API 和 SQL.Table API 是用于 Scala 和 Java 语言的查询API,它可以用一种非常直观的方式来组合使用选取&#x2F;过滤&#x2F;join 等关系型算子.Flink SQL 是基于 Apache Calcite 来实现的标准 SQL.无论输入是连续的(流式)还是有界的(批处理),在两个接口中指定的查询都具有相同">
<meta property="og:type" content="article">
<meta property="og:title" content="flink table api">
<meta property="og:url" content="https://maoeryu.github.io/2022/08/22/flink%20table%20api/index.html">
<meta property="og:site_name" content="FlyingPig">
<meta property="og:description" content="Apache Flink 有两种关系型 API 来做流批统一处理:Table API 和 SQL.Table API 是用于 Scala 和 Java 语言的查询API,它可以用一种非常直观的方式来组合使用选取&#x2F;过滤&#x2F;join 等关系型算子.Flink SQL 是基于 Apache Calcite 来实现的标准 SQL.无论输入是连续的(流式)还是有界的(批处理),在两个接口中指定的查询都具有相同">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://maoeryu.github.io/images/flgl46.png">
<meta property="og:image" content="https://maoeryu.github.io/images/flgl47.png">
<meta property="og:image" content="https://maoeryu.github.io/images/flgl48.png">
<meta property="og:image" content="https://maoeryu.github.io/images/flgl49.png">
<meta property="og:image" content="https://maoeryu.github.io/images/flgl50.png">
<meta property="og:image" content="https://maoeryu.github.io/images/flgl51.png">
<meta property="og:image" content="https://maoeryu.github.io/images/flgl52.png">
<meta property="og:image" content="https://maoeryu.github.io/images/flgl53.png">
<meta property="og:image" content="https://maoeryu.github.io/images/flgl54.png">
<meta property="og:image" content="https://maoeryu.github.io/images/flgl55.png">
<meta property="og:image" content="https://maoeryu.github.io/images/flgl56.png">
<meta property="og:image" content="https://maoeryu.github.io/images/flgl57.png">
<meta property="article:published_time" content="2022-08-21T16:00:00.000Z">
<meta property="article:modified_time" content="2022-12-02T06:12:46.702Z">
<meta property="article:author" content="maoeryu">
<meta property="article:tag" content="flink">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://maoeryu.github.io/images/flgl46.png">


<link rel="canonical" href="https://maoeryu.github.io/2022/08/22/flink%20table%20api/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>
<title>flink table api | FlyingPig</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">FlyingPig</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E4%B8%8E%E9%80%9A%E7%94%A8-API"><span class="nav-number">1.</span> <span class="nav-text">概念与通用 API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Table-API-%E5%92%8C-SQL-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">Table API 和 SQL 程序的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-TableEnvironment"><span class="nav-number">1.2.</span> <span class="nav-text">创建 TableEnvironment</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8-Catalog-%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%A1%A8"><span class="nav-number">1.3.</span> <span class="nav-text">在 Catalog 中创建表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%B4%E6%97%B6%E8%A1%A8-Temporary-Table-%E5%92%8C%E6%B0%B8%E4%B9%85%E8%A1%A8-Permanent-Table"><span class="nav-number">1.3.1.</span> <span class="nav-text">临时表(Temporary Table)和永久表(Permanent Table)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%8F%E8%94%BD-Shadowing"><span class="nav-number">1.3.2.</span> <span class="nav-text">屏蔽(Shadowing)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%A1%A8"><span class="nav-number">1.3.3.</span> <span class="nav-text">创建表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E8%A1%A8"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">虚拟表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Connector-Tables"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">Connector Tables</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E8%A1%A8%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-number">1.3.4.</span> <span class="nav-text">扩展表标识符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E8%A1%A8"><span class="nav-number">1.4.</span> <span class="nav-text">查询表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Table-API"><span class="nav-number">1.4.1.</span> <span class="nav-text">Table API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SQL"><span class="nav-number">1.4.2.</span> <span class="nav-text">SQL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B7%E7%94%A8-Table-API-%E5%92%8C-SQL"><span class="nav-number">1.4.3.</span> <span class="nav-text">混用 Table API 和 SQL</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E8%A1%A8"><span class="nav-number">1.5.</span> <span class="nav-text">输出表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BF%BB%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.6.</span> <span class="nav-text">翻译与执行查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="nav-number">1.7.</span> <span class="nav-text">查询优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E8%A1%A8"><span class="nav-number">1.8.</span> <span class="nav-text">解释表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E5%BC%8F%E6%A6%82%E5%BF%B5"><span class="nav-number">2.</span> <span class="nav-text">流式概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="nav-number">2.1.</span> <span class="nav-text">状态管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E4%BD%BF%E7%94%A8"><span class="nav-number">2.1.1.</span> <span class="nav-text">状态使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E7%8A%B6%E6%80%81%E7%BB%B4%E6%8C%81%E6%97%B6%E9%97%B4"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">空闲状态维持时间</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E5%8C%96%E6%9B%B4%E6%96%B0%E4%B8%8E%E6%BC%94%E5%8C%96"><span class="nav-number">2.1.2.</span> <span class="nav-text">状态化更新与演化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A1%A8-Dynamic-Table"><span class="nav-number">2.2.</span> <span class="nav-text">动态表 (Dynamic Table)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DataStream-%E4%B8%8A%E7%9A%84%E5%85%B3%E7%B3%BB%E6%9F%A5%E8%AF%A2"><span class="nav-number">2.2.1.</span> <span class="nav-text">DataStream 上的关系查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A1%A8-amp-%E8%BF%9E%E7%BB%AD%E6%9F%A5%E8%AF%A2-Continuous-Query"><span class="nav-number">2.2.2.</span> <span class="nav-text">动态表 &amp; 连续查询(Continuous Query)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E6%B5%81%E4%B8%8A%E5%AE%9A%E4%B9%89%E8%A1%A8"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">在流上定义表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E6%9F%A5%E8%AF%A2"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">连续查询</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E5%92%8C%E8%BF%BD%E5%8A%A0%E6%9F%A5%E8%AF%A2"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">更新和追加查询</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E9%99%90%E5%88%B6"><span class="nav-number">2.2.2.4.</span> <span class="nav-text">查询限制</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E5%88%B0%E6%B5%81%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.2.3.</span> <span class="nav-text">表到流的转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%B1%9E%E6%80%A7"><span class="nav-number">2.3.</span> <span class="nav-text">时间属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%B1%9E%E6%80%A7%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.3.1.</span> <span class="nav-text">时间属性介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4"><span class="nav-number">2.3.2.</span> <span class="nav-text">处理时间</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E5%88%9B%E5%BB%BA%E8%A1%A8%E7%9A%84-DDL-%E4%B8%AD%E5%AE%9A%E4%B9%89"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">在创建表的 DDL 中定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8-DataStream-%E5%88%B0-Table-%E8%BD%AC%E6%8D%A2%E6%97%B6%E5%AE%9A%E4%B9%89"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">在 DataStream 到 Table 转换时定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-TableSource-%E5%AE%9A%E4%B9%89"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">使用 TableSource 定义</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E6%97%B6%E9%97%B4"><span class="nav-number">2.3.3.</span> <span class="nav-text">事件时间</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8-DDL-%E4%B8%AD%E5%AE%9A%E4%B9%89"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">在 DDL 中定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8-DataStream-%E5%88%B0-Table-%E8%BD%AC%E6%8D%A2%E6%97%B6%E5%AE%9A%E4%B9%89-1"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">在 DataStream 到 Table 转换时定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-TableSource-%E5%AE%9A%E4%B9%89-1"><span class="nav-number">2.3.3.3.</span> <span class="nav-text">使用 TableSource 定义</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E6%80%81%E8%A1%A8-Temporal-Tables"><span class="nav-number">2.4.</span> <span class="nav-text">时态表(Temporal Tables)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E5%88%9D%E8%A1%B7"><span class="nav-number">2.4.1.</span> <span class="nav-text">设计初衷</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E4%B8%80%E5%BC%A0%E7%89%88%E6%9C%AC%E8%A1%A8"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">关联一张版本表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E4%B8%80%E5%BC%A0%E6%99%AE%E9%80%9A%E8%A1%A8"><span class="nav-number">2.4.1.2.</span> <span class="nav-text">关联一张普通表</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E6%80%81%E8%A1%A8"><span class="nav-number">2.4.2.</span> <span class="nav-text">时态表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E7%89%88%E6%9C%AC%E8%A1%A8"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">声明版本表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E7%89%88%E6%9C%AC%E8%A7%86%E5%9B%BE"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">声明版本视图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E6%99%AE%E9%80%9A%E8%A1%A8"><span class="nav-number">2.4.2.3.</span> <span class="nav-text">声明普通表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E6%80%81%E8%A1%A8%E5%87%BD%E6%95%B0"><span class="nav-number">2.5.</span> <span class="nav-text">时态表函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%97%B6%E6%80%81%E8%A1%A8%E5%87%BD%E6%95%B0"><span class="nav-number">2.5.1.</span> <span class="nav-text">定义时态表函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E6%80%81%E8%A1%A8%E5%87%BD%E6%95%B0%E8%BF%9E%E6%8E%A5-Join"><span class="nav-number">2.5.2.</span> <span class="nav-text">时态表函数连接(Join)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Performance-Tuning-%E6%B5%81%E5%BC%8F%E8%81%9A%E5%90%88"><span class="nav-number">2.6.</span> <span class="nav-text">Performance Tuning(流式聚合)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MiniBatch-%E8%81%9A%E5%90%88"><span class="nav-number">2.6.1.</span> <span class="nav-text">MiniBatch 聚合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Local-Global-%E8%81%9A%E5%90%88"><span class="nav-number">2.6.2.</span> <span class="nav-text">Local-Global 聚合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%86%E5%88%86-distinct-%E8%81%9A%E5%90%88"><span class="nav-number">2.6.3.</span> <span class="nav-text">拆分 distinct 聚合</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8-distinct-%E8%81%9A%E5%90%88%E4%B8%8A%E4%BD%BF%E7%94%A8-FILTER-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">2.7.</span> <span class="nav-text">在 distinct 聚合上使用 FILTER 修饰符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-Data-Types"><span class="nav-number">3.</span> <span class="nav-text">数据类型(Data Types)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Data-Type"><span class="nav-number">3.1.</span> <span class="nav-text">Data Type</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Table-API-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.1.1.</span> <span class="nav-text">Table API 中的数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E6%8F%90%E7%A4%BA-Physical-Hints"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">物理提示(Physical Hints)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%97%E8%A1%A8"><span class="nav-number">3.2.</span> <span class="nav-text">数据类型列表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Character-Strings-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">3.2.1.</span> <span class="nav-text">Character Strings(字符串)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CHAR"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">CHAR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#VARCHAR-STRING"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">VARCHAR &#x2F; STRING</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Binary-Strings-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">3.2.2.</span> <span class="nav-text">Binary Strings(二进制字符串)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#BINARY"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">BINARY</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#VARBINARY-BYTES"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">VARBINARY &#x2F; BYTES</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exact-Numerics-%E7%B2%BE%E7%A1%AE%E6%95%B0%E5%AD%97"><span class="nav-number">3.2.3.</span> <span class="nav-text">Exact Numerics(精确数字)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#DECIMAL"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">DECIMAL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TINYINT"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">TINYINT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SMALLINT"><span class="nav-number">3.2.3.3.</span> <span class="nav-text">SMALLINT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#INT"><span class="nav-number">3.2.3.4.</span> <span class="nav-text">INT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#BIGINT"><span class="nav-number">3.2.3.5.</span> <span class="nav-text">BIGINT</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Approximate-Numerics-%E8%BF%91%E4%BC%BC%E6%95%B0%E5%AD%97"><span class="nav-number">3.2.4.</span> <span class="nav-text">Approximate Numerics(近似数字)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#FLOAT"><span class="nav-number">3.2.4.1.</span> <span class="nav-text">FLOAT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DOUBLE"><span class="nav-number">3.2.4.2.</span> <span class="nav-text">DOUBLE</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Date-and-Time-%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4"><span class="nav-number">3.2.5.</span> <span class="nav-text">Date and Time(日期和时间)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#DATE"><span class="nav-number">3.2.5.1.</span> <span class="nav-text">DATE</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TIME"><span class="nav-number">3.2.5.2.</span> <span class="nav-text">TIME</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TIMESTAMP"><span class="nav-number">3.2.5.3.</span> <span class="nav-text">TIMESTAMP</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TIMESTAMP-WITH-TIME-ZONE"><span class="nav-number">3.2.5.4.</span> <span class="nav-text">TIMESTAMP WITH TIME ZONE</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TIMESTAMP-LTZ"><span class="nav-number">3.2.5.5.</span> <span class="nav-text">TIMESTAMP_LTZ</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#INTERVAL-YEAR-TO-MONTH"><span class="nav-number">3.2.5.6.</span> <span class="nav-text">INTERVAL YEAR TO MONTH</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#INTERVAL-DAY-TO-SECOND"><span class="nav-number">3.2.5.7.</span> <span class="nav-text">INTERVAL DAY TO SECOND</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Constructured-Data-Types-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.2.6.</span> <span class="nav-text">Constructured Data Types(构造数据类型)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ARRAY"><span class="nav-number">3.2.6.1.</span> <span class="nav-text">ARRAY</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MAP"><span class="nav-number">3.2.6.2.</span> <span class="nav-text">MAP</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MULTISET"><span class="nav-number">3.2.6.3.</span> <span class="nav-text">MULTISET</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ROW"><span class="nav-number">3.2.6.4.</span> <span class="nav-text">ROW</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.2.7.</span> <span class="nav-text">用户定义的数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E7%9A%84%E7%BB%93%E6%9E%84%E5%8C%96%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.2.7.1.</span> <span class="nav-text">注册的结构化类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%AA%E6%B3%A8%E5%86%8C%E7%9A%84%E7%BB%93%E6%9E%84%E5%8C%96%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.2.7.2.</span> <span class="nav-text">未注册的结构化类型</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.2.8.</span> <span class="nav-text">其他数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#BOOLEAN"><span class="nav-number">3.2.8.1.</span> <span class="nav-text">BOOLEAN</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RAW"><span class="nav-number">3.2.8.2.</span> <span class="nav-text">RAW</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#NULL"><span class="nav-number">3.2.8.3.</span> <span class="nav-text">NULL</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAST-%E6%96%B9%E6%B3%95"><span class="nav-number">3.3.</span> <span class="nav-text">CAST 方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A7%E7%89%88%E6%9C%AC-CAST-%E6%96%B9%E6%B3%95"><span class="nav-number">3.3.1.</span> <span class="nav-text">旧版本 CAST 方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%8F%90%E5%8F%96"><span class="nav-number">3.4.</span> <span class="nav-text">数据类型提取</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E5%8C%BA"><span class="nav-number">4.</span> <span class="nav-text">时区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TIMESTAMP-vs-TIMESTAMP-LTZ"><span class="nav-number">4.1.</span> <span class="nav-text">TIMESTAMP vs TIMESTAMP_LTZ</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TIMESTAMP-%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.1.</span> <span class="nav-text">TIMESTAMP 类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TIMESTAMP-LTZ-%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.2.</span> <span class="nav-text">TIMESTAMP_LTZ 类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E5%8C%BA%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">4.2.</span> <span class="nav-text">时区的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AE%E5%AE%9A%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">4.2.1.</span> <span class="nav-text">确定时间函数的返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TIMESTAMP-LTZ-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8%E7%A4%BA"><span class="nav-number">4.2.2.</span> <span class="nav-text">TIMESTAMP_LTZ 字符串表示</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%B1%9E%E6%80%A7%E5%92%8C%E6%97%B6%E5%8C%BA"><span class="nav-number">4.3.</span> <span class="nav-text">时间属性和时区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%B6%E5%8C%BA"><span class="nav-number">4.3.1.</span> <span class="nav-text">处理时间和时区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%B6%E5%8C%BA"><span class="nav-number">4.3.2.</span> <span class="nav-text">事件时间和时区</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#TIMESTAMP-%E4%B8%8A%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%97%B6%E9%97%B4%E5%B1%9E%E6%80%A7"><span class="nav-number">4.3.2.1.</span> <span class="nav-text">TIMESTAMP 上的事件时间属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TIMESTAMP-LTZ-%E4%B8%8A%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%97%B6%E9%97%B4%E5%B1%9E%E6%80%A7"><span class="nav-number">4.3.2.2.</span> <span class="nav-text">TIMESTAMP_LTZ 上的事件时间属性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8F%E4%BB%A4%E6%97%B6%E6%94%AF%E6%8C%81"><span class="nav-number">4.4.</span> <span class="nav-text">夏令时支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Batch-%E6%A8%A1%E5%BC%8F%E5%92%8C-Streaming-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.5.</span> <span class="nav-text">Batch 模式和 Streaming 模式的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Table-API-1"><span class="nav-number">5.</span> <span class="nav-text">Table API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-amp-%E7%A4%BA%E4%BE%8B"><span class="nav-number">5.1.</span> <span class="nav-text">概述 &amp; 示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Operations"><span class="nav-number">5.2.</span> <span class="nav-text">Operations</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Scan-Projection-and-Filter"><span class="nav-number">5.2.1.</span> <span class="nav-text">Scan, Projection, and Filter</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#From"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">From</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FromValues"><span class="nav-number">5.2.1.2.</span> <span class="nav-text">FromValues</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Select"><span class="nav-number">5.2.1.3.</span> <span class="nav-text">Select</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#As"><span class="nav-number">5.2.1.4.</span> <span class="nav-text">As</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Where-Filter"><span class="nav-number">5.2.1.5.</span> <span class="nav-text">Where &#x2F; Filter</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%E6%93%8D%E4%BD%9C"><span class="nav-number">5.2.2.</span> <span class="nav-text">列操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#AddColumns"><span class="nav-number">5.2.2.1.</span> <span class="nav-text">AddColumns</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AddOrReplaceColumns"><span class="nav-number">5.2.2.2.</span> <span class="nav-text">AddOrReplaceColumns</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DropColumns"><span class="nav-number">5.2.2.3.</span> <span class="nav-text">DropColumns</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RenameColumns"><span class="nav-number">5.2.2.4.</span> <span class="nav-text">RenameColumns</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Aggregations"><span class="nav-number">5.2.2.5.</span> <span class="nav-text">Aggregations</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GroupBy-Window-Aggregation"><span class="nav-number">5.2.2.6.</span> <span class="nav-text">GroupBy Window Aggregation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Over-Window-Aggregation"><span class="nav-number">5.2.2.7.</span> <span class="nav-text">Over Window Aggregation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Distinct-Aggregation"><span class="nav-number">5.2.2.8.</span> <span class="nav-text">Distinct Aggregation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Distinct"><span class="nav-number">5.2.2.9.</span> <span class="nav-text">Distinct</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Joins"><span class="nav-number">5.2.3.</span> <span class="nav-text">Joins</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Inner-Join"><span class="nav-number">5.2.3.1.</span> <span class="nav-text">Inner Join</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Outer-Join"><span class="nav-number">5.2.3.2.</span> <span class="nav-text">Outer Join</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Interval-Join"><span class="nav-number">5.2.3.3.</span> <span class="nav-text">Interval Join</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Inner-Join-with-Table-Function-UDTF"><span class="nav-number">5.2.3.4.</span> <span class="nav-text">Inner Join with Table Function (UDTF)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Left-Outer-Join-with-Table-Function-UDTF"><span class="nav-number">5.2.3.5.</span> <span class="nav-text">Left Outer Join with Table Function (UDTF)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Set-Operations"><span class="nav-number">5.2.4.</span> <span class="nav-text">Set Operations</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Union"><span class="nav-number">5.2.4.1.</span> <span class="nav-text">Union</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#UnionAll"><span class="nav-number">5.2.4.2.</span> <span class="nav-text">UnionAll</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Intersect"><span class="nav-number">5.2.4.3.</span> <span class="nav-text">Intersect</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#IntersectAll"><span class="nav-number">5.2.4.4.</span> <span class="nav-text">IntersectAll</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Minus"><span class="nav-number">5.2.4.5.</span> <span class="nav-text">Minus</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MinusAll"><span class="nav-number">5.2.4.6.</span> <span class="nav-text">MinusAll</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#In"><span class="nav-number">5.2.4.7.</span> <span class="nav-text">In</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OrderBy-Offset-amp-Fetch"><span class="nav-number">5.2.5.</span> <span class="nav-text">OrderBy, Offset &amp; Fetch</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Order-By"><span class="nav-number">5.2.5.1.</span> <span class="nav-text">Order By</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Offset-amp-Fetch"><span class="nav-number">5.2.5.2.</span> <span class="nav-text">Offset &amp; Fetch</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Insert"><span class="nav-number">5.2.6.</span> <span class="nav-text">Insert</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Group-Windows"><span class="nav-number">5.2.7.</span> <span class="nav-text">Group Windows</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Tumble-Tumbling-Windows"><span class="nav-number">5.2.7.1.</span> <span class="nav-text">Tumble (Tumbling Windows)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Slide-Sliding-Windows"><span class="nav-number">5.2.7.2.</span> <span class="nav-text">Slide (Sliding Windows)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Session-Session-Windows"><span class="nav-number">5.2.7.3.</span> <span class="nav-text">Session (Session Windows)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Over-Windows"><span class="nav-number">5.2.8.</span> <span class="nav-text">Over Windows</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Partition-By"><span class="nav-number">5.2.8.1.</span> <span class="nav-text">Partition By</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Order-By-1"><span class="nav-number">5.2.8.2.</span> <span class="nav-text">Order By</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Preceding"><span class="nav-number">5.2.8.3.</span> <span class="nav-text">Preceding</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Following"><span class="nav-number">5.2.8.4.</span> <span class="nav-text">Following</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#As-1"><span class="nav-number">5.2.8.5.</span> <span class="nav-text">As</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Row-based-Operations"><span class="nav-number">5.2.9.</span> <span class="nav-text">Row-based Operations</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Map"><span class="nav-number">5.2.9.1.</span> <span class="nav-text">Map</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FlatMap"><span class="nav-number">5.2.9.2.</span> <span class="nav-text">FlatMap</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Aggregate"><span class="nav-number">5.2.9.3.</span> <span class="nav-text">Aggregate</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Group-Window-Aggregate"><span class="nav-number">5.2.9.4.</span> <span class="nav-text">Group Window Aggregate</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FlatAggregate"><span class="nav-number">5.2.9.5.</span> <span class="nav-text">FlatAggregate</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">maoeryu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">221</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://maoeryu.github.io/2022/08/22/flink%20table%20api/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="maoeryu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FlyingPig">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          flink table api
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-08-22 00:00:00" itemprop="dateCreated datePublished" datetime="2022-08-22T00:00:00+08:00">2022-08-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-12-02 14:12:46" itemprop="dateModified" datetime="2022-12-02T14:12:46+08:00">2022-12-02</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%8D%8F%E5%90%8C%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">协同框架</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>Apache Flink 有两种关系型 API 来做流批统一处理:Table API 和 SQL.<br>Table API 是用于 Scala 和 Java 语言的查询API,它可以用一种非常直观的方式来组合使用选取/过滤/join 等关系型算子.<br>Flink SQL 是基于 Apache Calcite 来实现的标准 SQL.<br>无论输入是连续的(流式)还是有界的(批处理),在两个接口中指定的查询都具有相同的语义,并指定相同的结果.</p>
<p>Table API 和 SQL 两种 API 是紧密集成的,以及 DataStream API.<br>你可以在这些 API 之间,以及一些基于这些 API 的库之间轻松的切换.<br>比如,你可以先用 CEP 从 DataStream 中做模式匹配,然后用 Table API 来分析匹配的结果.<br>或者你可以用 SQL 来扫描/过滤/聚合一个批式的表,然后再跑一个 Gelly 图算法来处理已经预处理好的数据.</p>
<span id="more"></span>
<h2 id="概念与通用-API"><a href="#概念与通用-API" class="headerlink" title="概念与通用 API"></a>概念与通用 API</h2><p>Table API 和 SQL 集成在同一套 API 中.<br>这套 API 的核心概念是Table,用作查询的输入和输出.</p>
<h3 id="Table-API-和-SQL-程序的结构"><a href="#Table-API-和-SQL-程序的结构" class="headerlink" title="Table API 和 SQL 程序的结构"></a>Table API 和 SQL 程序的结构</h3><p>所有用于批处理和流处理的 Table API 和 SQL 程序都遵循相同的模式.<br>下面的代码示例展示了 Table API 和 SQL 程序的通用结构.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.table.api.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.connector.datagen.table.DataGenOptions;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a TableEnvironment for batch or streaming execution.</span></span><br><span class="line"><span class="comment">// See the &quot;Create a TableEnvironment&quot; section for details.</span></span><br><span class="line">TableEnvironment tableEnv = TableEnvironment.create(<span class="comment">/*…*/</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a source table</span></span><br><span class="line">tableEnv.createTemporaryTable(<span class="string">&quot;SourceTable&quot;</span>, TableDescriptor.forConnector(<span class="string">&quot;datagen&quot;</span>)</span><br><span class="line">  .schema(Schema.newBuilder()</span><br><span class="line">    .column(<span class="string">&quot;f0&quot;</span>, DataTypes.STRING())</span><br><span class="line">    .build())</span><br><span class="line">  .option(DataGenOptions.ROWS_PER_SECOND, <span class="number">100</span>)</span><br><span class="line">  .build());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a sink table (using SQL DDL)</span></span><br><span class="line">tableEnv.executeSql(<span class="string">&quot;CREATE TEMPORARY TABLE SinkTable WITH (&#x27;connector&#x27; = &#x27;blackhole&#x27;) LIKE SourceTable&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a Table object from a Table API query</span></span><br><span class="line">Table table2 = tableEnv.from(<span class="string">&quot;SourceTable&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a Table object from a SQL query</span></span><br><span class="line">Table table3 = tableEnv.sqlQuery(<span class="string">&quot;SELECT * FROM SourceTable&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Emit a Table API result Table to a TableSink, same for SQL result</span></span><br><span class="line">TableResult tableResult = table2.insertInto(<span class="string">&quot;SinkTable&quot;</span>).execute();</span><br></pre></td></tr></table></figure>

<h3 id="创建-TableEnvironment"><a href="#创建-TableEnvironment" class="headerlink" title="创建 TableEnvironment"></a>创建 TableEnvironment</h3><p>TableEnvironment 是 Table API 和 SQL 的核心概念.它负责:</p>
<ol>
<li>在内部的 catalog 中注册 Table</li>
<li>注册外部的 catalog</li>
<li>加载可插拔模块</li>
<li>执行 SQL 查询</li>
<li>注册自定义函数 (scalar/table 或 aggregation)</li>
<li>DataStream 和 Table 之间的转换(面向 StreamTableEnvironment )</li>
</ol>
<p>Table 总是与特定的 TableEnvironment 绑定.<br>不能在同一条查询中使用不同 TableEnvironment 中的表,例如,对它们进行 join 或 union 操作.<br>TableEnvironment 可以通过静态方法 TableEnvironment.create() 创建.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.table.api.EnvironmentSettings;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.table.api.TableEnvironment;</span><br><span class="line"></span><br><span class="line">EnvironmentSettings settings = EnvironmentSettings</span><br><span class="line">  .newInstance()</span><br><span class="line">  .inStreamingMode()</span><br><span class="line">  <span class="comment">//.inBatchMode()</span></span><br><span class="line">  .build();</span><br><span class="line"></span><br><span class="line">TableEnvironment tEnv = TableEnvironment.create(settings);</span><br></pre></td></tr></table></figure>

<p>或者,用户可以从现有的 StreamExecutionEnvironment 创建一个 StreamTableEnvironment 与 DataStream API 互操作.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.table.api.EnvironmentSettings;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.table.api.bridge.java.StreamTableEnvironment;</span><br><span class="line"></span><br><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">StreamTableEnvironment tEnv = StreamTableEnvironment.create(env);</span><br></pre></td></tr></table></figure>

<h3 id="在-Catalog-中创建表"><a href="#在-Catalog-中创建表" class="headerlink" title="在 Catalog 中创建表"></a>在 Catalog 中创建表</h3><p>TableEnvironment 维护着一个由标识符(identifier)创建的表 catalog 的映射.<br>标识符由三个部分组成:catalog 名称/数据库名称以及对象名称.<br>如果 catalog 或者数据库没有指明,就会使用当前默认值.</p>
<p>Table 可以是虚拟的(视图 VIEWS)也可以是常规的(表 TABLES).<br>视图 VIEWS可以从已经存在的Table中创建,一般是 Table API 或者 SQL 的查询结果.<br>表TABLES描述的是外部数据,例如文件/数据库表或者消息队列.</p>
<h4 id="临时表-Temporary-Table-和永久表-Permanent-Table"><a href="#临时表-Temporary-Table-和永久表-Permanent-Table" class="headerlink" title="临时表(Temporary Table)和永久表(Permanent Table)"></a>临时表(Temporary Table)和永久表(Permanent Table)</h4><p>表可以是临时的,并与单个 Flink 会话(session)的生命周期相关,也可以是永久的,并且在多个 Flink 会话和群集(cluster)中可见.</p>
<p>永久表需要 catalog(例如 Hive Metastore)以维护表的元数据.<br>一旦永久表被创建,它将对任何连接到 catalog 的 Flink 会话可见且持续存在,直至被明确删除.</p>
<p>另一方面,临时表通常保存于内存中并且仅在创建它们的 Flink 会话持续期间存在.<br>这些表对于其它会话是不可见的.<br>它们不与任何 catalog 或者数据库绑定但可以在一个命名空间(namespace)中创建.<br>即使它们对应的数据库被删除,临时表也不会被删除.</p>
<h4 id="屏蔽-Shadowing"><a href="#屏蔽-Shadowing" class="headerlink" title="屏蔽(Shadowing)"></a>屏蔽(Shadowing)</h4><p>可以使用与已存在的永久表相同的标识符去注册临时表.<br>临时表会屏蔽永久表,并且只要临时表存在,永久表就无法访问.<br>所有使用该标识符的查询都将作用于临时表.</p>
<p>这可能对实验(experimentation)有用.<br>它允许先对一个临时表进行完全相同的查询,例如只有一个子集的数据,或者数据是不确定的.<br>一旦验证了查询的正确性,就可以对实际的生产表进行查询.</p>
<h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><h5 id="虚拟表"><a href="#虚拟表" class="headerlink" title="虚拟表"></a>虚拟表</h5><p>在 SQL 的术语中,Table API 的对象对应于视图(虚拟表).<br>它封装了一个逻辑查询计划.<br>它可以通过以下方法在 catalog 中创建:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get a TableEnvironment</span></span><br><span class="line">TableEnvironment tableEnv = ...; <span class="comment">// see &quot;Create a TableEnvironment&quot; section</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// table is the result of a simple projection query </span></span><br><span class="line">Table projTable = tableEnv.from(<span class="string">&quot;X&quot;</span>).select(...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// register the Table projTable as table &quot;projectedTable&quot;</span></span><br><span class="line">tableEnv.createTemporaryView(<span class="string">&quot;projectedTable&quot;</span>, projTable);</span><br></pre></td></tr></table></figure>

<p>注意: 从传统数据库系统的角度来看,Table 对象与 VIEW 视图非常像.<br>也就是,定义了 Table 的查询是没有被优化的, 而且会被内嵌到另一个引用了这个注册了的 Table的查询中.<br>如果多个查询都引用了同一个注册了的Table,那么它会被内嵌每个查询中并被执行多次, 也就是说注册了的Table的结果不会被共享.</p>
<h5 id="Connector-Tables"><a href="#Connector-Tables" class="headerlink" title="Connector Tables"></a>Connector Tables</h5><p>另外一个方式去创建 TABLE 是通过 connector 声明.<br>Connector 描述了存储表数据的外部系统.<br>存储系统例如 Apache Kafka 或者常规的文件系统都可以通过这种方式来声明.</p>
<p>Such tables can either be created using the Table API directly, or by switching to SQL DDL.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Using table descriptors</span></span><br><span class="line"><span class="keyword">final</span> TableDescriptor sourceDescriptor = TableDescriptor.forConnector(<span class="string">&quot;datagen&quot;</span>)</span><br><span class="line">  .schema(Schema.newBuilder()</span><br><span class="line">  .column(<span class="string">&quot;f0&quot;</span>, DataTypes.STRING())</span><br><span class="line">  .build())</span><br><span class="line">  .option(DataGenOptions.ROWS_PER_SECOND, <span class="number">100</span>)</span><br><span class="line">  .build();</span><br><span class="line"></span><br><span class="line">tableEnv.createTable(<span class="string">&quot;SourceTableA&quot;</span>, sourceDescriptor);</span><br><span class="line">tableEnv.createTemporaryTable(<span class="string">&quot;SourceTableB&quot;</span>, sourceDescriptor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Using SQL DDL</span></span><br><span class="line">tableEnv.executeSql(<span class="string">&quot;CREATE [TEMPORARY] TABLE MyTable (...) WITH (...)&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="扩展表标识符"><a href="#扩展表标识符" class="headerlink" title="扩展表标识符"></a>扩展表标识符</h4><p>表总是通过三元标识符注册,包括 catalog 名/数据库名和表名.</p>
<p>用户可以指定一个 catalog 和数据库作为 &quot;当前catalog&quot; 和&quot;当前数据库&quot;.<br>有了这些,那么刚刚提到的三元标识符的前两个部分就可以被省略了.<br>如果前两部分的标识符没有指定, 那么会使用当前的 catalog 和当前数据库.<br>用户也可以通过 Table API 或 SQL 切换当前的 catalog 和当前的数据库.</p>
<p>标识符遵循 SQL 标准,因此使用时需要用反引号(`)进行转义.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">TableEnvironment tEnv = ...;</span><br><span class="line">tEnv.useCatalog(<span class="string">&quot;custom_catalog&quot;</span>);</span><br><span class="line">tEnv.useDatabase(<span class="string">&quot;custom_database&quot;</span>);</span><br><span class="line"></span><br><span class="line">Table table = ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// register the view named &#x27;exampleView&#x27; in the catalog named &#x27;custom_catalog&#x27;</span></span><br><span class="line"><span class="comment">// in the database named &#x27;custom_database&#x27; </span></span><br><span class="line">tableEnv.createTemporaryView(<span class="string">&quot;exampleView&quot;</span>, table);</span><br><span class="line"></span><br><span class="line"><span class="comment">// register the view named &#x27;exampleView&#x27; in the catalog named &#x27;custom_catalog&#x27;</span></span><br><span class="line"><span class="comment">// in the database named &#x27;other_database&#x27; </span></span><br><span class="line">tableEnv.createTemporaryView(<span class="string">&quot;other_database.exampleView&quot;</span>, table);</span><br><span class="line"></span><br><span class="line"><span class="comment">// register the view named &#x27;example.View&#x27; in the catalog named &#x27;custom_catalog&#x27;</span></span><br><span class="line"><span class="comment">// in the database named &#x27;custom_database&#x27; </span></span><br><span class="line">tableEnv.createTemporaryView(<span class="string">&quot;`example.View`&quot;</span>, table);</span><br><span class="line"></span><br><span class="line"><span class="comment">// register the view named &#x27;exampleView&#x27; in the catalog named &#x27;other_catalog&#x27;</span></span><br><span class="line"><span class="comment">// in the database named &#x27;other_database&#x27; </span></span><br><span class="line">tableEnv.createTemporaryView(<span class="string">&quot;other_catalog.other_database.exampleView&quot;</span>, table);</span><br></pre></td></tr></table></figure>

<h3 id="查询表"><a href="#查询表" class="headerlink" title="查询表"></a>查询表</h3><h4 id="Table-API"><a href="#Table-API" class="headerlink" title="Table API"></a>Table API</h4><p>Table API 是关于 Scala 和 Java 的集成语言式查询 API.<br>与 SQL 相反,Table API 的查询不是由字符串指定,而是在宿主语言中逐步构建.</p>
<p>Table API 是基于 Table 类的,该类表示一个表(流或批处理),并提供使用关系操作的方法.<br>这些方法返回一个新的 Table 对象,该对象表示对输入 Table 进行关系操作的结果.<br>一些关系操作由多个方法调用组成,例如 table.groupBy(...).select(),其中 groupBy(...) 指定 table 的分组,而 select(...) 在 table 分组上的投影.</p>
<p>以下示例展示了一个简单的 Table API 聚合查询:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get a TableEnvironment</span></span><br><span class="line">TableEnvironment tableEnv = ...; <span class="comment">// see &quot;Create a TableEnvironment&quot; section</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// register Orders table</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// scan registered Orders table</span></span><br><span class="line">Table orders = tableEnv.from(<span class="string">&quot;Orders&quot;</span>);</span><br><span class="line"><span class="comment">// compute revenue for all customers from France</span></span><br><span class="line">Table revenue = orders</span><br><span class="line"> .filter($(<span class="string">&quot;cCountry&quot;</span>).isEqual(<span class="string">&quot;FRANCE&quot;</span>))</span><br><span class="line"> .groupBy($(<span class="string">&quot;cID&quot;</span>), $(<span class="string">&quot;cName&quot;</span>))</span><br><span class="line"> .select($(<span class="string">&quot;cID&quot;</span>), $(<span class="string">&quot;cName&quot;</span>), $(<span class="string">&quot;revenue&quot;</span>).sum().as(<span class="string">&quot;revSum&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// emit or convert Table</span></span><br><span class="line"><span class="comment">// execute query</span></span><br></pre></td></tr></table></figure>

<h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><p>Flink SQL 是基于实现了SQL标准的 Apache Calcite 的.<br>SQL 查询由常规字符串指定.</p>
<p>下面的示例演示了如何指定查询并将结果作为 Table 对象返回.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get a TableEnvironment</span></span><br><span class="line">TableEnvironment tableEnv = ...; <span class="comment">// see &quot;Create a TableEnvironment&quot; section</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// register Orders table</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// compute revenue for all customers from France</span></span><br><span class="line">Table revenue = tableEnv.sqlQuery(</span><br><span class="line">  <span class="string">&quot;SELECT cID, cName, SUM(revenue) AS revSum &quot;</span> +</span><br><span class="line">  <span class="string">&quot;FROM Orders &quot;</span> +</span><br><span class="line">  <span class="string">&quot;WHERE cCountry = &#x27;FRANCE&#x27; &quot;</span> +</span><br><span class="line">  <span class="string">&quot;GROUP BY cID, cName&quot;</span></span><br><span class="line"> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// emit or convert Table</span></span><br><span class="line"><span class="comment">// execute query</span></span><br></pre></td></tr></table></figure>

<p>如下的示例展示了如何指定一个更新查询,将查询的结果插入到已注册的表中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get a TableEnvironment</span></span><br><span class="line">TableEnvironment tableEnv = ...; <span class="comment">// see &quot;Create a TableEnvironment&quot; section</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// register &quot;Orders&quot; table</span></span><br><span class="line"><span class="comment">// register &quot;RevenueFrance&quot; output table</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// compute revenue for all customers from France and emit to &quot;RevenueFrance&quot;</span></span><br><span class="line">tableEnv.executeSql(</span><br><span class="line">  <span class="string">&quot;INSERT INTO RevenueFrance &quot;</span> +</span><br><span class="line">  <span class="string">&quot;SELECT cID, cName, SUM(revenue) AS revSum &quot;</span> +</span><br><span class="line">  <span class="string">&quot;FROM Orders &quot;</span> +</span><br><span class="line">  <span class="string">&quot;WHERE cCountry = &#x27;FRANCE&#x27; &quot;</span> +</span><br><span class="line">  <span class="string">&quot;GROUP BY cID, cName&quot;</span></span><br><span class="line"> );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="混用-Table-API-和-SQL"><a href="#混用-Table-API-和-SQL" class="headerlink" title="混用 Table API 和 SQL"></a>混用 Table API 和 SQL</h4><p>Table API 和 SQL 查询的混用非常简单因为它们都返回 Table 对象:</p>
<ol>
<li>可以在 SQL 查询返回的 Table 对象上定义 Table API 查询.</li>
<li>在 TableEnvironment 中注册的结果表可以在 SQL 查询的 FROM 子句中引用,通过这种方法就可以在 Table API 查询的结果上定义 SQL 查询.</li>
</ol>
<h3 id="输出表"><a href="#输出表" class="headerlink" title="输出表"></a>输出表</h3><p>Table 通过写入 TableSink 输出.<br>TableSink 是一个通用接口,用于支持多种文件格式(如 CSV/Apache Parquet/Apache Avro)/存储系统(如 JDBC/Apache HBase/Apache Cassandra/Elasticsearch)或消息队列系统(如 Apache Kafka/RabbitMQ).</p>
<p>批处理 Table 只能写入 BatchTableSink,而流处理 Table 需要指定写入 AppendStreamTableSink,RetractStreamTableSink 或者 UpsertStreamTableSink.</p>
<p>方法 Table.insertInto(String tableName) 定义了一个完整的端到端管道将源表中的数据传输到一个被注册的输出表中.<br>该方法通过名称在 catalog 中查找输出表并确认 Table schema 和输出表 schema 一致.<br>可以通过方法 TablePipeline.explain() 和 TablePipeline.execute() 分别来解释和执行一个数据流管道.</p>
<p>下面的示例演示如何输出 Table:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get a TableEnvironment</span></span><br><span class="line">TableEnvironment tableEnv = ...; <span class="comment">// see &quot;Create a TableEnvironment&quot; section</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// create an output Table</span></span><br><span class="line"><span class="keyword">final</span> Schema schema = Schema.newBuilder()</span><br><span class="line">  .column(<span class="string">&quot;a&quot;</span>, DataTypes.INT())</span><br><span class="line">  .column(<span class="string">&quot;b&quot;</span>, DataTypes.STRING())</span><br><span class="line">  .column(<span class="string">&quot;c&quot;</span>, DataTypes.BIGINT())</span><br><span class="line">  .build();</span><br><span class="line"></span><br><span class="line">tableEnv.createTemporaryTable(<span class="string">&quot;CsvSinkTable&quot;</span>, TableDescriptor.forConnector(<span class="string">&quot;filesystem&quot;</span>)</span><br><span class="line">  .schema(schema)</span><br><span class="line">  .option(<span class="string">&quot;path&quot;</span>, <span class="string">&quot;/path/to/file&quot;</span>)</span><br><span class="line">  .format(FormatDescriptor.forFormat(<span class="string">&quot;csv&quot;</span>)</span><br><span class="line">      .option(<span class="string">&quot;field-delimiter&quot;</span>, <span class="string">&quot;|&quot;</span>)</span><br><span class="line">      .build())</span><br><span class="line">  .build());</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute a result Table using Table API operators and/or SQL queries</span></span><br><span class="line">Table result = ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare the insert into pipeline</span></span><br><span class="line">TablePipeline pipeline = result.insertInto(<span class="string">&quot;CsvSinkTable&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print explain details</span></span><br><span class="line">pipeline.printExplain();</span><br><span class="line"></span><br><span class="line"><span class="comment">// emit the result Table to the registered TableSink</span></span><br><span class="line">pipeline.execute();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="翻译与执行查询"><a href="#翻译与执行查询" class="headerlink" title="翻译与执行查询"></a>翻译与执行查询</h3><p>不论输入数据源是流式的还是批式的,Table API 和 SQL 查询都会被转换成 DataStream 程序.<br>查询在内部表示为逻辑查询计划,并被翻译成两个阶段:</p>
<ol>
<li>优化逻辑执行计划</li>
<li>翻译成 DataStream 程序</li>
</ol>
<p>Table API 或者 SQL 查询在下列情况下会被翻译:</p>
<ol>
<li>当 TableEnvironment.executeSql() 被调用时.<br>该方法是用来执行一个 SQL 语句,一旦该方法被调用, SQL 语句立即被翻译.</li>
<li>当 TablePipeline.execute() 被调用时.<br>该方法是用来执行一个源表到输出表的数据流,一旦该方法被调用, TABLE API 程序立即被翻译.</li>
<li>当 Table.execute() 被调用时.<br>该方法是用来将一个表的内容收集到本地,一旦该方法被调用, TABLE API 程序立即被翻译.</li>
<li>当 StatementSet.execute() 被调用时.<br>TablePipeline (通过 StatementSet.add() 输出给某个 Sink)和 INSERT 语句 (通过调用 StatementSet.addInsertSql())会先被缓存到 StatementSet 中,StatementSet.execute() 方法被调用时,所有的 sink 会被优化成一张有向无环图.</li>
<li>当 Table 被转换成 DataStream 时.<br>转换完成后,它就成为一个普通的 DataStream 程序,并会在调用 StreamExecutionEnvironment.execute() 时被执行.</li>
</ol>
<h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><p>Apache Flink 使用并扩展了 Apache Calcite 来执行复杂的查询优化.<br>这包括一系列基于规则和成本的优化,例如:</p>
<ol>
<li>基于 Apache Calcite 的子查询解相关</li>
<li>投影剪裁</li>
<li>分区剪裁</li>
<li>过滤器下推</li>
<li>子计划消除重复数据以避免重复计算</li>
<li>特殊子查询重写,包括两部分:将 IN 和 EXISTS 转换为 left semi-joins.将 NOT IN 和 NOT EXISTS 转换为 left anti-join.</li>
<li>可选 join 重新排序, 通过 table.optimizer.join-reorder-enabled 启用</li>
</ol>
<blockquote>
<p>当前仅在子查询重写的结合条件下支持 IN / EXISTS / NOT IN / NOT EXISTS.</p>
</blockquote>
<p>优化器不仅基于计划,而且还基于可从数据源获得的丰富统计信息以及每个算子(例如 io,cpu,网络和内存)的细粒度成本来做出明智的决策.<br>高级用户可以通过 CalciteConfig 对象提供自定义优化,可以通过调用 TableEnvironment＃getConfig＃setPlannerConfig 将其提供给 TableEnvironment.</p>
<h3 id="解释表"><a href="#解释表" class="headerlink" title="解释表"></a>解释表</h3><p>Table API 提供了一种机制来解释计算 Table 的逻辑和优化查询计划.<br>这是通过 Table.explain() 方法或者 StatementSet.explain() 方法来完成的.<br>Table.explain() 返回一个 Table 的计划.<br>StatementSet.explain() 返回多 sink 计划的结果.<br>它返回一个描述三种计划的字符串:</p>
<p>关系查询的抽象语法树(the Abstract Syntax Tree),即未优化的逻辑查询计划,<br>优化的逻辑查询计划,以及<br>物理执行计划.</p>
<p>可以用 TableEnvironment.explainSql() 方法和 TableEnvironment.executeSql() 方法支持执行一个 EXPLAIN 语句获取逻辑和优化查询计划.</p>
<p>以下代码展示了一个示例以及对给定 Table 使用 Table.explain() 方法的相应输出:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">StreamTableEnvironment tEnv = StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line">DataStream&lt;Tuple2&lt;Integer, String&gt;&gt; stream1 = env.fromElements(<span class="keyword">new</span> Tuple2&lt;&gt;(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>));</span><br><span class="line">DataStream&lt;Tuple2&lt;Integer, String&gt;&gt; stream2 = env.fromElements(<span class="keyword">new</span> Tuple2&lt;&gt;(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// explain Table API</span></span><br><span class="line">Table table1 = tEnv.fromDataStream(stream1, $(<span class="string">&quot;count&quot;</span>), $(<span class="string">&quot;word&quot;</span>));</span><br><span class="line">Table table2 = tEnv.fromDataStream(stream2, $(<span class="string">&quot;count&quot;</span>), $(<span class="string">&quot;word&quot;</span>));</span><br><span class="line">Table table = table1</span><br><span class="line"> .where($(<span class="string">&quot;word&quot;</span>).like(<span class="string">&quot;F%&quot;</span>))</span><br><span class="line"> .unionAll(table2);</span><br><span class="line"></span><br><span class="line">System.out.println(table.explain());</span><br></pre></td></tr></table></figure>

<p>以下代码展示了一个示例以及使用 StatementSet.explain() 的多 sink 计划的相应输出:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">EnvironmentSettings settings = EnvironmentSettings.inStreamingMode();</span><br><span class="line">TableEnvironment tEnv = TableEnvironment.create(settings);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Schema schema = Schema.newBuilder()</span><br><span class="line">  .column(<span class="string">&quot;count&quot;</span>, DataTypes.INT())</span><br><span class="line">  .column(<span class="string">&quot;word&quot;</span>, DataTypes.STRING())</span><br><span class="line">  .build();</span><br><span class="line"></span><br><span class="line">tEnv.createTemporaryTable(<span class="string">&quot;MySource1&quot;</span>, TableDescriptor.forConnector(<span class="string">&quot;filesystem&quot;</span>)</span><br><span class="line">  .schema(schema)</span><br><span class="line">  .option(<span class="string">&quot;path&quot;</span>, <span class="string">&quot;/source/path1&quot;</span>)</span><br><span class="line">  .format(<span class="string">&quot;csv&quot;</span>)</span><br><span class="line">  .build());</span><br><span class="line">tEnv.createTemporaryTable(<span class="string">&quot;MySource2&quot;</span>, TableDescriptor.forConnector(<span class="string">&quot;filesystem&quot;</span>)</span><br><span class="line">  .schema(schema)</span><br><span class="line">  .option(<span class="string">&quot;path&quot;</span>, <span class="string">&quot;/source/path2&quot;</span>)</span><br><span class="line">  .format(<span class="string">&quot;csv&quot;</span>)</span><br><span class="line">  .build());</span><br><span class="line">tEnv.createTemporaryTable(<span class="string">&quot;MySink1&quot;</span>, TableDescriptor.forConnector(<span class="string">&quot;filesystem&quot;</span>)</span><br><span class="line">  .schema(schema)</span><br><span class="line">  .option(<span class="string">&quot;path&quot;</span>, <span class="string">&quot;/sink/path1&quot;</span>)</span><br><span class="line">  .format(<span class="string">&quot;csv&quot;</span>)</span><br><span class="line">  .build());</span><br><span class="line">tEnv.createTemporaryTable(<span class="string">&quot;MySink2&quot;</span>, TableDescriptor.forConnector(<span class="string">&quot;filesystem&quot;</span>)</span><br><span class="line">  .schema(schema)</span><br><span class="line">  .option(<span class="string">&quot;path&quot;</span>, <span class="string">&quot;/sink/path2&quot;</span>)</span><br><span class="line">  .format(<span class="string">&quot;csv&quot;</span>)</span><br><span class="line">  .build());</span><br><span class="line"></span><br><span class="line">StatementSet stmtSet = tEnv.createStatementSet();</span><br><span class="line"></span><br><span class="line">Table table1 = tEnv.from(<span class="string">&quot;MySource1&quot;</span>).where($(<span class="string">&quot;word&quot;</span>).like(<span class="string">&quot;F%&quot;</span>));</span><br><span class="line">stmtSet.add(table1.insertInto(<span class="string">&quot;MySink1&quot;</span>));</span><br><span class="line"></span><br><span class="line">Table table2 = table1.unionAll(tEnv.from(<span class="string">&quot;MySource2&quot;</span>));</span><br><span class="line">stmtSet.add(table2.insertInto(<span class="string">&quot;MySink2&quot;</span>));</span><br><span class="line"></span><br><span class="line">String explanation = stmtSet.explain();</span><br><span class="line">System.out.println(explanation);</span><br></pre></td></tr></table></figure>

<h2 id="流式概念"><a href="#流式概念" class="headerlink" title="流式概念"></a>流式概念</h2><p>Flink 的 Table API 和 SQL 是流批统一的 API.<br>这意味着 Table API &amp; SQL 在无论有限的批式输入还是无限的流式输入下,都具有相同的语义.<br>因为传统的关系代数以及 SQL 最开始都是为了批式处理而设计的, 关系型查询在流式场景下不如在批式场景下容易懂.</p>
<h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><p>流模式下运行的表程序利用了 Flink 作为有状态流处理器的所有能力.</p>
<p>事实上,一个表程序(Table program)可以配置一个 state backend 和多个不同的 checkpoint 选项 以处理对不同状态大小和容错需求.<br>这可以对正在运行的 Table API &amp; SQL 管道(pipeline)生成 savepoint,并在这之后用其恢复应用程序的状态.</p>
<h4 id="状态使用"><a href="#状态使用" class="headerlink" title="状态使用"></a>状态使用</h4><p>由于 Table API &amp; SQL 程序是声明式的,管道内的状态会在哪以及如何被使用并不明确.<br>Planner 会确认是否需要状态来得到正确的计算结果, 管道会被现有优化规则集优化成尽可能少地使用状态.</p>
<blockquote>
<p>从概念上讲, 源表从来不会在状态中被完全保存.<br>实现者处理的是逻辑表(即动态表).<br>它们的状态取决于用到的操作.</p>
</blockquote>
<p>形如 SELECT ... FROM ... WHERE 这种只包含字段映射或过滤器的查询的查询语句通常是无状态的管道.<br>然而诸如 join/ 聚合或去重操作需要在 Flink 抽象的容错存储内保存中间结果.</p>
<p>例如对两个表进行 join 操作的普通 SQL 需要算子保存两个表的全部输入.<br>基于正确的 SQL 语义,运行时假设两表会在任意时间点进行匹配.<br>Flink 提供了 优化窗口和时段 Join 聚合 以利用 watermarks 概念来让保持较小的状态规模.</p>
<p>另一个计算每个会话的点击次数的查询语句的例子如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sessionId, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> clicks <span class="keyword">GROUP</span> <span class="keyword">BY</span> sessionId;</span><br></pre></td></tr></table></figure>

<p>sessionId 是用于分组的键,连续查询(Continuous Query)维护了每个观察到的 sessionId 次数.<br>sessionId 属性随着时间逐步演变, 且 sessionId 的值只活跃到会话结束(即在有限的时间周期内).<br>然而连续查询无法得知sessionId的这个性质, 并且预期每个 sessionId 值会在任何时间点上出现.<br>这维护了每个可见的 sessionId 值.<br>因此总状态量会随着 sessionId 的发现不断地增长.</p>
<h5 id="空闲状态维持时间"><a href="#空闲状态维持时间" class="headerlink" title="空闲状态维持时间"></a>空闲状态维持时间</h5><p>空间状态位置时间参数 <code>table.exec.state.ttl</code> 定义了状态的键在被更新后要保持多长时间才被移除.<br>在之前的查询例子中,sessionId 的数目会在配置的时间内未更新时立刻被移除.</p>
<p>通过移除状态的键,连续查询会完全忘记它曾经见过这个键.<br>如果一个状态带有曾被移除状态的键被处理了,这条记录将被认为是 对应键的第一条记录.<br>上述例子中意味着 sessionId 会再次从 0 开始计数.</p>
<h4 id="状态化更新与演化"><a href="#状态化更新与演化" class="headerlink" title="状态化更新与演化"></a>状态化更新与演化</h4><p>表程序在流模式下执行将被视为标准查询,这意味着它们被定义一次后将被一直视为静态的端到端 (end-to-end) 管道.</p>
<p>对于这种状态化的管道,对查询和Flink的Planner的改动都有可能导致完全不同的执行计划.<br>这让表程序的状态化的升级和演化在目前而言 仍具有挑战,社区正致力于改进这一缺点.</p>
<p>例如为了添加过滤谓词,优化器可能决定重排 join 或改变内部算子的 schema.<br>这会阻碍从 savepoint 的恢复,因为其被改变的拓扑和 算子状态的列布局差异.</p>
<p>查询实现者需要确保改变在优化计划前后是兼容的,在 SQL 中使用 EXPLAIN 或在 Table API 中使用 table.explain() 可获取详情.<br>由于新的优化器规则正不断地被添加,算子变得更加高效和专用,升级到更新的Flink版本可能造成不兼容的计划.<br>当前框架无法保证状态可以从 savepoint 映射到新的算子拓扑上.<br>换言之: Savepoint 只在查询语句和版本保持恒定的情况下被支持.</p>
<h3 id="动态表-Dynamic-Table"><a href="#动态表-Dynamic-Table" class="headerlink" title="动态表 (Dynamic Table)"></a>动态表 (Dynamic Table)</h3><h4 id="DataStream-上的关系查询"><a href="#DataStream-上的关系查询" class="headerlink" title="DataStream 上的关系查询"></a>DataStream 上的关系查询</h4><p>下表比较了传统的关系代数和流处理与输入数据/执行和输出结果的关系.</p>
<table>
<thead>
<tr>
<th>关系代数 / SQL</th>
<th>流处理</th>
</tr>
</thead>
<tbody><tr>
<td>关系(或表)是有界(多)元组集合.</td>
<td>流是一个无限元组序列.</td>
</tr>
<tr>
<td>对批数据(例如关系数据库中的表)执行的查询可以访问完整的输入数据.</td>
<td>流式查询在启动时不能访问所有数据,必须&quot;等待&quot;数据流入.</td>
</tr>
<tr>
<td>批处理查询在产生固定大小的结果后终止.</td>
<td>流查询不断地根据接收到的记录更新其结果,并且始终不会结束.</td>
</tr>
</tbody></table>
<p>尽管存在这些差异,但是使用关系查询和 SQL 处理流并不是不可能的.<br>高级关系数据库系统提供了一个称为 物化视图(Materialized Views) 的特性.<br>物化视图被定义为一条 SQL 查询,就像常规的虚拟视图一样.<br>与虚拟视图相反,物化视图缓存查询的结果,因此在访问视图时不需要对查询进行计算.<br>缓存的一个常见难题是防止缓存为过期的结果提供服务.<br>当其定义查询的基表被修改时,物化视图将过期.<br>即时视图维护(Eager View Maintenance) 是一种一旦更新了物化视图的基表就立即更新视图的技术.</p>
<p>如果我们考虑以下问题,那么即时视图维护和流上的SQL查询之间的联系就会变得显而易见:</p>
<ol>
<li>数据库表是 INSERT/UPDATE 和 DELETE DML 语句的 stream 的结果,通常称为 changelog stream .</li>
<li>物化视图被定义为一条 SQL 查询.为了更新视图,查询不断地处理视图的基本关系的changelog 流.</li>
<li>物化视图是流式 SQL 查询的结果.</li>
</ol>
<h4 id="动态表-amp-连续查询-Continuous-Query"><a href="#动态表-amp-连续查询-Continuous-Query" class="headerlink" title="动态表 &amp; 连续查询(Continuous Query)"></a>动态表 &amp; 连续查询(Continuous Query)</h4><p>动态表 是 Flink 的支持流数据的 Table API 和 SQL 的核心概念.<br>与表示批处理数据的静态表不同,动态表是随时间变化的.<br>可以像查询静态批处理表一样查询它们.<br>查询动态表将生成一个 连续查询 .<br>一个连续查询永远不会终止,结果会生成一个动态表.<br>查询不断更新其(动态)结果表,以反映其(动态)输入表上的更改.<br>本质上,动态表上的连续查询非常类似于定义物化视图的查询.</p>
<p>需要注意的是,连续查询的结果在语义上总是等价于以批处理模式在输入表快照上执行的相同查询的结果.</p>
<p>下图显示了流/动态表和连续查询之间的关系:</p>
<img src="/images/flgl46.png" style="margin-left: 0px; padding-bottom: 10px;">

<ol>
<li>将流转换为动态表.</li>
<li>在动态表上计算一个连续查询,生成一个新的动态表.</li>
<li>生成的动态表被转换回流.</li>
</ol>
<blockquote>
<p>注意: 动态表首先是一个逻辑概念.在查询执行期间不一定(完全)物化动态表.</p>
</blockquote>
<p>在下面,我们将解释动态表和连续查询的概念,并使用具有以下模式的单击事件流:<br>[<br> user:  VARCHAR,   // 用户名<br> cTime: TIMESTAMP, // 访问 URL 的时间<br> url:   VARCHAR    // 用户访问的 URL<br>]</p>
<h5 id="在流上定义表"><a href="#在流上定义表" class="headerlink" title="在流上定义表"></a>在流上定义表</h5><p>为了使用关系查询处理流,必须将其转换成 Table.<br>从概念上讲,流的每条记录都被解释为对结果表的 INSERT 操作.<br>本质上我们正在从一个 INSERT-only 的 changelog 流构建表.</p>
<p>下图显示了单击事件流(左侧)如何转换为表(右侧).<br>当插入更多的单击流记录时,结果表将不断增长.</p>
<img src="/images/flgl47.png" style="margin-left: 0px; padding-bottom: 10px;">

<blockquote>
<p>注意: 在流上定义的表在内部没有物化.</p>
</blockquote>
<h5 id="连续查询"><a href="#连续查询" class="headerlink" title="连续查询"></a>连续查询</h5><p>在动态表上计算一个连续查询,并生成一个新的动态表.<br>与批处理查询不同,连续查询从不终止,并根据其输入表上的更新更新其结果表.<br>在任何时候,连续查询的结果在语义上与以批处理模式在输入表快照上执行的相同查询的结果相同.</p>
<p>在接下来的代码中,我们将展示 clicks 表上的两个示例查询,这个表是在点击事件流上定义的.</p>
<p>第一个查询是一个简单的 GROUP-BY COUNT 聚合查询.<br>它基于 user 字段对 clicks 表进行分组,并统计访问的 URL 的数量.<br>下面的图显示了当 clicks 表被附加的行更新时,查询是如何被评估的.</p>
<img src="/images/flgl48.png" style="margin-left: 0px; padding-bottom: 10px;">

<p>当查询开始,clicks 表(左侧)是空的.<br>当第一行数据被插入到 clicks 表时,查询开始计算结果表.<br>第一行数据 <code>[Mary,./home]</code> 插入后,结果表(右侧,上部)由一行 <code>[Mary, 1]</code> 组成.<br>当第二行 <code>[Bob, ./cart]</code> 插入到 clicks 表时,查询会更新结果表并插入了一行新数据 <code>[Bob, 1]</code>.<br>第三行 <code>[Mary, ./prod?id=1]</code> 将产生已计算的结果行的更新,<code>[Mary, 1]</code> 更新成 <code>[Mary, 2]</code>.<br>最后,当第四行数据加入 clicks 表时,查询将第三行 <code>[Liz, 1]</code> 插入到结果表中.</p>
<p>第二条查询与第一条类似,但是除了用户属性之外,还将 clicks 分组至每小时滚动窗口中,然后计算 url 数量.<br>同样,该图显示了不同时间点的输入和输出,以可视化动态表的变化特性.</p>
<img src="/images/flgl49.png" style="margin-left: 0px; padding-bottom: 10px;">

<p>与前面一样,左边显示了输入表 clicks.<br>查询每小时持续计算结果并更新结果表.<br>clicks表包含四行带有时间戳(cTime)的数据,时间戳在 12:00:00 和 12:59:59 之间.<br>查询从这个输入计算出两个结果行(每个 user 一个),并将它们附加到结果表中.<br>对于 13:00:00 和 13:59:59 之间的下一个窗口,clicks 表包含三行,这将导致另外两行被追加到结果表.<br>随着时间的推移,更多的行被添加到 click 中,结果表将被更新.</p>
<h5 id="更新和追加查询"><a href="#更新和追加查询" class="headerlink" title="更新和追加查询"></a>更新和追加查询</h5><p>虽然这两个示例查询看起来非常相似(都计算分组计数聚合),但它们在一个重要方面不同:</p>
<ol>
<li>第一个查询更新先前输出的结果,即定义结果表的 changelog 流包含 INSERT 和 UPDATE 操作.</li>
<li>第二个查询只附加到结果表,即结果表的 changelog 流只包含 INSERT 操作.</li>
<li>一个查询是产生一个只追加的表还是一个更新的表有一些含义:</li>
<li>产生更新更改的查询通常必须维护更多的状态(请参阅以下部分).</li>
<li>将 append-only 的表转换为流与将已更新的表转换为流是不同的(参阅表到流的转换章节).</li>
</ol>
<h5 id="查询限制"><a href="#查询限制" class="headerlink" title="查询限制"></a>查询限制</h5><p>许多(但不是全部)语义上有效的查询可以作为流上的连续查询进行评估.<br>有些查询代价太高而无法计算,这可能是由于它们需要维护的状态大小,也可能是由于计算更新代价太高.</p>
<p><strong>状态大小</strong>:<br>连续查询在无界流上计算,通常应该运行数周或数月.<br>因此,连续查询处理的数据总量可能非常大.<br>必须更新先前输出的结果的查询需要维护所有输出的行,以便能够更新它们.<br>例如,第一个查询示例需要存储每个用户的 URL 计数,以便能够增加该计数并在输入表接收新行时发送新结果.<br>如果只跟踪注册用户,则要维护的计数数量可能不会太高.<br>但是,如果未注册的用户分配了一个惟一的用户名,那么要维护的计数数量将随着时间增长,并可能最终导致查询失败.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span>, <span class="built_in">COUNT</span>(url)</span><br><span class="line"><span class="keyword">FROM</span> clicks</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<p><strong>计算更新</strong>:<br>有些查询需要重新计算和更新大量已输出的结果行,即使只添加或更新一条输入记录.<br>显然,这样的查询不适合作为连续查询执行.<br>下面的查询就是一个例子,它根据最后一次单击的时间为每个用户计算一个 RANK.<br>一旦 click 表接收到一个新行,用户的 lastAction 就会更新,并必须计算一个新的排名.<br>然而,由于两行不能具有相同的排名,所以所有较低排名的行也需要更新.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span>, <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> lastAction)</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line"> <span class="keyword">SELECT</span> <span class="keyword">user</span>, <span class="built_in">MAX</span>(cTime) <span class="keyword">AS</span> lastAction <span class="keyword">FROM</span> clicks <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">user</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>查询配置章节讨论了控制连续查询执行的参数.<br>一些参数可以用来在维持状态的大小和获得结果的准确性之间做取舍.</p>
<h4 id="表到流的转换"><a href="#表到流的转换" class="headerlink" title="表到流的转换"></a>表到流的转换</h4><p>动态表可以像普通数据库表一样通过 INSERT/UPDATE 和 DELETE 来不断修改.<br>它可能是一个只有一行/不断更新的表,也可能是一个 insert-only 的表,没有 UPDATE 和 DELETE 修改,或者介于两者之间的其他表.</p>
<p>在将动态表转换为流或将其写入外部系统时,需要对这些更改进行编码.<br>Flink的 Table API 和 SQL 支持三种方式来编码一个动态表的变化:</p>
<p><strong>Append-only 流</strong>:<br>仅通过 INSERT 操作修改的动态表可以通过输出插入的行转换为流.</p>
<p><strong>Retract 流</strong>:<br>retract 流包含两种类型的 message: add messages 和 retract messages .<br>通过将INSERT 操作编码为 add message/将 DELETE 操作编码为 retract message/将 UPDATE 操作编码为更新(先前)行的 retract message 和更新(新)行的 add message,将动态表转换为 retract 流.<br>下图显示了将动态表转换为 retract 流的过程.</p>
<img src="/images/flgl50.png" style="margin-left: 0px; padding-bottom: 10px;">

<p><strong>Upsert 流</strong>:<br>upsert 流包含两种类型的 message: upsert messages 和delete messages.<br>转换为 upsert 流的动态表需要(可能是组合的)唯一键.<br>通过将 INSERT 和 UPDATE 操作编码为 upsert message,将 DELETE 操作编码为 delete message ,将具有唯一键的动态表转换为流.<br>消费流的算子需要知道唯一键的属性,以便正确地应用 message.<br>与 retract 流的主要区别在于 UPDATE 操作是用单个 message 编码的,因此效率更高.<br>下图显示了将动态表转换为 upsert 流的过程.</p>
<img src="/images/flgl51.png" style="margin-left: 0px; padding-bottom: 10px;">

<p>在通用概念中讨论了将动态表转换为 DataStream 的 API.<br>请注意,在将动态表转换为 DataStream 时,只支持 append 流和 retract 流.<br>在 TableSources 和 TableSinks 章节讨论向外部系统输出动态表的 TableSink 接口.</p>
<h3 id="时间属性"><a href="#时间属性" class="headerlink" title="时间属性"></a>时间属性</h3><p>Flink 可以基于几种不同的 时间 概念来处理数据.</p>
<ol>
<li>处理时间 指的是执行具体操作时的机器时间(大家熟知的绝对时间, 例如 Java的 System.currentTimeMillis()) )</li>
<li>事件时间 指的是数据本身携带的时间.这个时间是在事件产生时的时间.</li>
<li>摄入时间 指的是数据进入 Flink 的时间.在系统内部,会把它当做事件时间来处理.</li>
</ol>
<h4 id="时间属性介绍"><a href="#时间属性介绍" class="headerlink" title="时间属性介绍"></a>时间属性介绍</h4><p>像窗口(在 Table API 和 SQL )这种基于时间的操作,需要有时间信息.<br>因此,Table API 中的表就需要提供逻辑时间属性来表示时间,以及支持时间相关的操作.</p>
<p>每种类型的表都可以有时间属性,可以在用CREATE TABLE DDL创建表的时候指定/也可以在 DataStream 中指定/也可以在定义 TableSource 时指定.<br>一旦时间属性定义好,它就可以像普通列一样使用,也可以在时间相关的操作中使用.</p>
<p>只要时间属性没有被修改,而是简单地从一个表传递到另一个表,它就仍然是一个有效的时间属性.<br>时间属性可以像普通的时间戳的列一样被使用和计算.<br>一旦时间属性被用在了计算中,它就会被物化,进而变成一个普通的时间戳.<br>普通的时间戳是无法跟 Flink 的时间以及watermark等一起使用的,所以普通的时间戳就无法用在时间相关的操作中.</p>
<p>Table API 程序需要在 streaming environment 中指定时间属性:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime); <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者:</span></span><br><span class="line"><span class="comment">// env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime);</span></span><br><span class="line"><span class="comment">// env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span></span><br></pre></td></tr></table></figure>

<h4 id="处理时间"><a href="#处理时间" class="headerlink" title="处理时间"></a>处理时间</h4><p>处理时间是基于机器的本地时间来处理数据,它是最简单的一种时间概念,但是它不能提供确定性.<br>它既不需要从数据里获取时间,也不需要生成 watermark.</p>
<p>共有三种方法可以定义处理时间.</p>
<h5 id="在创建表的-DDL-中定义"><a href="#在创建表的-DDL-中定义" class="headerlink" title="在创建表的 DDL 中定义"></a>在创建表的 DDL 中定义</h5><p>处理时间属性可以在创建表的 DDL 中用计算列的方式定义,用 PROCTIME() 就可以定义处理时间,函数 PROCTIME() 的返回类型是 TIMESTAMP_LTZ .</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_actions (</span><br><span class="line"> user_name STRING,</span><br><span class="line"> data STRING,</span><br><span class="line"> user_action_time <span class="keyword">AS</span> PROCTIME() <span class="comment">-- 声明一个额外的列作为处理时间属性</span></span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line"> ...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> TUMBLE_START(user_action_time, <span class="type">INTERVAL</span> <span class="string">&#x27;10&#x27;</span> <span class="keyword">MINUTE</span>), <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> user_name)</span><br><span class="line"><span class="keyword">FROM</span> user_actions</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> TUMBLE(user_action_time, <span class="type">INTERVAL</span> <span class="string">&#x27;10&#x27;</span> <span class="keyword">MINUTE</span>);</span><br></pre></td></tr></table></figure>

<h5 id="在-DataStream-到-Table-转换时定义"><a href="#在-DataStream-到-Table-转换时定义" class="headerlink" title="在 DataStream 到 Table 转换时定义"></a>在 DataStream 到 Table 转换时定义</h5><p>处理时间属性可以在 schema 定义的时候用 .proctime 后缀来定义.<br>时间属性一定不能定义在一个已有字段上,所以它只能定义在 schema 定义的最后.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Tuple2&lt;String, String&gt;&gt; stream = ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个额外的字段作为时间属性字段</span></span><br><span class="line">Table table = tEnv.fromDataStream(stream, $(<span class="string">&quot;user_name&quot;</span>), $(<span class="string">&quot;data&quot;</span>), $(<span class="string">&quot;user_action_time&quot;</span>).proctime());</span><br><span class="line"></span><br><span class="line">WindowedTable windowedTable = table.window(</span><br><span class="line">      Tumble.over(lit(<span class="number">10</span>).minutes())</span><br><span class="line">          .on($(<span class="string">&quot;user_action_time&quot;</span>))</span><br><span class="line">          .as(<span class="string">&quot;userActionWindow&quot;</span>));</span><br></pre></td></tr></table></figure>

<h5 id="使用-TableSource-定义"><a href="#使用-TableSource-定义" class="headerlink" title="使用 TableSource 定义"></a>使用 TableSource 定义</h5><p>处理时间属性可以在实现了 DefinedProctimeAttribute 的 TableSource 中定义.<br>逻辑的时间属性会放在 TableSource 已有物理字段的最后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个由处理时间属性的 table source</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserActionSource</span> <span class="keyword">implements</span> <span class="title">StreamTableSource</span>&lt;<span class="title">Row</span>&gt;, <span class="title">DefinedProctimeAttribute</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> TypeInformation&lt;Row&gt; <span class="title">getReturnType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String[] names = <span class="keyword">new</span> String[] &#123;<span class="string">&quot;user_name&quot;</span> , <span class="string">&quot;data&quot;</span>&#125;;</span><br><span class="line">  TypeInformation[] types = <span class="keyword">new</span> TypeInformation[] &#123;Types.STRING(), Types.STRING()&#125;;</span><br><span class="line">  <span class="keyword">return</span> Types.ROW(names, types);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> DataStream&lt;Row&gt; <span class="title">getDataStream</span><span class="params">(StreamExecutionEnvironment execEnv)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// create stream</span></span><br><span class="line">  DataStream&lt;Row&gt; stream = ...;</span><br><span class="line">  <span class="keyword">return</span> stream;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">getProctimeAttribute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这个名字的列会被追加到最后,作为第三列</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;user_action_time&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// register table source</span></span><br><span class="line">tEnv.registerTableSource(<span class="string">&quot;user_actions&quot;</span>, <span class="keyword">new</span> UserActionSource());</span><br><span class="line"></span><br><span class="line">WindowedTable windowedTable = tEnv</span><br><span class="line"> .from(<span class="string">&quot;user_actions&quot;</span>)</span><br><span class="line"> .window(Tumble</span><br><span class="line">    .over(lit(<span class="number">10</span>).minutes())</span><br><span class="line">    .on($(<span class="string">&quot;user_action_time&quot;</span>))</span><br><span class="line">    .as(<span class="string">&quot;userActionWindow&quot;</span>));</span><br></pre></td></tr></table></figure>

<h4 id="事件时间"><a href="#事件时间" class="headerlink" title="事件时间"></a>事件时间</h4><p>事件时间允许程序按照数据中包含的时间来处理,这样可以在有乱序或者晚到的数据的情况下产生一致的处理结果.<br>它可以保证从外部存储读取数据后产生可以复现(replayable)的结果.</p>
<p>除此之外,事件时间可以让程序在流式和批式作业中使用同样的语法.<br>在流式程序中的事件时间属性,在批式程序中就是一个正常的时间字段.</p>
<p>为了能够处理乱序的事件,并且区分正常到达和晚到的事件,Flink 需要从事件中获取事件时间并且产生 watermark(watermarks).</p>
<p>事件时间属性也有类似于处理时间的三种定义方式:在DDL中定义/在 DataStream 到 Table 转换时定义/用 TableSource 定义.</p>
<h5 id="在-DDL-中定义"><a href="#在-DDL-中定义" class="headerlink" title="在 DDL 中定义"></a>在 DDL 中定义</h5><p>事件时间属性可以用 WATERMARK 语句在 CREATE TABLE DDL 中进行定义.<br>WATERMARK 语句在一个已有字段上定义一个 watermark 生成表达式,同时标记这个已有字段为时间属性字段.</p>
<p>Flink 支持和在 TIMESTAMP 列和 TIMESTAMP_LTZ 列上定义事件时间.<br>如果源数据中的时间戳数据表示为年-月-日-时-分-秒,则通常为不带时区信息的字符串值,例如 2020-04-15 20:13:40.564,建议将事件时间属性定义在 TIMESTAMP 列上:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_actions (</span><br><span class="line"> user_name STRING,</span><br><span class="line"> data STRING,</span><br><span class="line"> user_action_time <span class="type">TIMESTAMP</span>(<span class="number">3</span>),</span><br><span class="line"> <span class="comment">-- 声明 user_action_time 是事件时间属性,并且用 延迟 5 秒的策略来生成 watermark</span></span><br><span class="line"> WATERMARK <span class="keyword">FOR</span> user_action_time <span class="keyword">AS</span> user_action_time <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">SECOND</span></span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line"> ...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> TUMBLE_START(user_action_time, <span class="type">INTERVAL</span> <span class="string">&#x27;10&#x27;</span> <span class="keyword">MINUTE</span>), <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> user_name)</span><br><span class="line"><span class="keyword">FROM</span> user_actions</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> TUMBLE(user_action_time, <span class="type">INTERVAL</span> <span class="string">&#x27;10&#x27;</span> <span class="keyword">MINUTE</span>);</span><br></pre></td></tr></table></figure>

<p>源数据中的时间戳数据表示为一个纪元 (epoch) 时间,通常是一个 long 值,例如 1618989564564,建议将事件时间属性定义在 TIMESTAMP_LTZ 列上:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_actions (</span><br><span class="line">user_name STRING,</span><br><span class="line">data STRING,</span><br><span class="line">ts <span class="type">BIGINT</span>,</span><br><span class="line">time_ltz <span class="keyword">AS</span> TO_TIMESTAMP_LTZ(ts, <span class="number">3</span>),</span><br><span class="line"><span class="comment">-- declare time_ltz as event time attribute and use 5 seconds delayed watermark strategy</span></span><br><span class="line">WATERMARK <span class="keyword">FOR</span> time_ltz <span class="keyword">AS</span> time_ltz <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">SECOND</span></span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> TUMBLE_START(time_ltz, <span class="type">INTERVAL</span> <span class="string">&#x27;10&#x27;</span> <span class="keyword">MINUTE</span>), <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> user_name)</span><br><span class="line"><span class="keyword">FROM</span> user_actions</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> TUMBLE(time_ltz, <span class="type">INTERVAL</span> <span class="string">&#x27;10&#x27;</span> <span class="keyword">MINUTE</span>);</span><br></pre></td></tr></table></figure>

<h5 id="在-DataStream-到-Table-转换时定义-1"><a href="#在-DataStream-到-Table-转换时定义-1" class="headerlink" title="在 DataStream 到 Table 转换时定义"></a>在 DataStream 到 Table 转换时定义</h5><p>事件时间属性可以用 .rowtime 后缀在定义 DataStream schema 的时候来定义.<br>时间戳和 watermark 在这之前一定是在 DataStream 上已经定义好了.<br>在从 DataStream 转换到 Table 时,由于 DataStream 没有时区概念,因此 Flink 总是将 rowtime 属性解析成 TIMESTAMP WITHOUT TIME ZONE 类型,并且将所有事件时间的值都视为 UTC 时区的值.</p>
<p>在从 DataStream 到 Table 转换时定义事件时间属性有两种方式.<br>取决于用 .rowtime 后缀修饰的字段名字是否是已有字段,事件时间字段可以是:</p>
<ol>
<li>在 schema 的结尾追加一个新的字段</li>
<li>替换一个已经存在的字段.</li>
</ol>
<p>不管在哪种情况下,事件时间字段都表示 DataStream 中定义的事件的时间戳.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Option 1:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于 stream 中的事件产生时间戳和 watermark</span></span><br><span class="line">DataStream&lt;Tuple2&lt;String, String&gt;&gt; stream = inputStream.assignTimestampsAndWatermarks(...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个额外的逻辑字段作为事件时间属性</span></span><br><span class="line">Table table = tEnv.fromDataStream(stream, $(<span class="string">&quot;user_name&quot;</span>), $(<span class="string">&quot;data&quot;</span>), $(<span class="string">&quot;user_action_time&quot;</span>).rowtime());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Option 2:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从第一个字段获取事件时间,并且产生 watermark</span></span><br><span class="line">DataStream&lt;Tuple3&lt;Long, String, String&gt;&gt; stream = inputStream.assignTimestampsAndWatermarks(...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个字段已经用作事件时间抽取了,不用再用一个新字段来表示事件时间了</span></span><br><span class="line">Table table = tEnv.fromDataStream(stream, $(<span class="string">&quot;user_action_time&quot;</span>).rowtime(), $(<span class="string">&quot;user_name&quot;</span>), $(<span class="string">&quot;data&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage:</span></span><br><span class="line"></span><br><span class="line">WindowedTable windowedTable = table.window(Tumble</span><br><span class="line">     .over(lit(<span class="number">10</span>).minutes())</span><br><span class="line">     .on($(<span class="string">&quot;user_action_time&quot;</span>))</span><br><span class="line">     .as(<span class="string">&quot;userActionWindow&quot;</span>));</span><br></pre></td></tr></table></figure>

<h5 id="使用-TableSource-定义-1"><a href="#使用-TableSource-定义-1" class="headerlink" title="使用 TableSource 定义"></a>使用 TableSource 定义</h5><p>事件时间属性可以在实现了 DefinedRowTimeAttributes 的 TableSource 中定义.<br>getRowtimeAttributeDescriptors() 方法返回 RowtimeAttributeDescriptor 的列表,包含了描述事件时间属性的字段名字/如何计算事件时间/以及 watermark 生成策略等信息.</p>
<p>同时需要确保 getDataStream 返回的 DataStream 已经定义好了时间属性.<br>只有在定义了 StreamRecordTimestamp 时间戳分配器的时候,才认为 DataStream 是有时间戳信息的.<br>只有定义了 PreserveWatermarks watermark 生成策略的 DataStream 的 watermark 才会被保留.<br>反之,则只有时间字段的值是生效的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个有事件时间属性的 table source</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserActionSource</span> <span class="keyword">implements</span> <span class="title">StreamTableSource</span>&lt;<span class="title">Row</span>&gt;, <span class="title">DefinedRowtimeAttributes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> TypeInformation&lt;Row&gt; <span class="title">getReturnType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String[] names = <span class="keyword">new</span> String[] &#123;<span class="string">&quot;user_name&quot;</span>, <span class="string">&quot;data&quot;</span>, <span class="string">&quot;user_action_time&quot;</span>&#125;;</span><br><span class="line">  TypeInformation[] types =</span><br><span class="line">      <span class="keyword">new</span> TypeInformation[] &#123;Types.STRING(), Types.STRING(), Types.LONG()&#125;;</span><br><span class="line">  <span class="keyword">return</span> Types.ROW(names, types);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> DataStream&lt;Row&gt; <span class="title">getDataStream</span><span class="params">(StreamExecutionEnvironment execEnv)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造 DataStream</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 基于 &quot;user_action_time&quot; 定义 watermark</span></span><br><span class="line">  DataStream&lt;Row&gt; stream = inputStream.assignTimestampsAndWatermarks(...);</span><br><span class="line">  <span class="keyword">return</span> stream;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> List&lt;RowtimeAttributeDescriptor&gt; <span class="title">getRowtimeAttributeDescriptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 标记 &quot;user_action_time&quot; 字段是事件时间字段</span></span><br><span class="line">  <span class="comment">// 给 &quot;user_action_time&quot; 构造一个时间属性描述符</span></span><br><span class="line">  RowtimeAttributeDescriptor rowtimeAttrDescr = <span class="keyword">new</span> RowtimeAttributeDescriptor(</span><br><span class="line">    <span class="string">&quot;user_action_time&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> ExistingField(<span class="string">&quot;user_action_time&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> AscendingTimestamps());</span><br><span class="line">  List&lt;RowtimeAttributeDescriptor&gt; listRowtimeAttrDescr = Collections.singletonList(rowtimeAttrDescr);</span><br><span class="line">  <span class="keyword">return</span> listRowtimeAttrDescr;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// register the table source</span></span><br><span class="line">tEnv.registerTableSource(<span class="string">&quot;user_actions&quot;</span>, <span class="keyword">new</span> UserActionSource());</span><br><span class="line"></span><br><span class="line">WindowedTable windowedTable = tEnv</span><br><span class="line"> .from(<span class="string">&quot;user_actions&quot;</span>)</span><br><span class="line"> .window(Tumble.over(lit(<span class="number">10</span>).minutes()).on($(<span class="string">&quot;user_action_time&quot;</span>)).as(<span class="string">&quot;userActionWindow&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="时态表-Temporal-Tables"><a href="#时态表-Temporal-Tables" class="headerlink" title="时态表(Temporal Tables)"></a>时态表(Temporal Tables)</h3><p>时态表(Temporal Table)是一张随时间变化的表.<br>在 Flink 中称为动态表,时态表中的每条记录都关联了一个或多个时间段,所有的 Flink 表都是时态的(动态的).</p>
<p>时态表包含表的一个或多个有版本的表快照,时态表可以是一张跟踪所有变更记录的表(例如数据库表的 changelog,包含多个表快照),也可以是物化所有变更之后的表(例如数据库表,只有最新表快照).</p>
<p><strong>版本</strong>:<br>时态表可以划分成一系列带版本的表快照集合,表快照中的版本代表了快照中所有记录的有效区间,有效区间的开始时间和结束时间可以通过用户指定,根据时态表是否可以追踪自身的历史版本与否,时态表可以分为 版本表 和 普通表.</p>
<p><strong>版本表</strong>:<br>如果时态表中的记录可以追踪和并访问它的历史版本,这种表我们称之为版本表,来自数据库的 changelog 可以定义成版本表.</p>
<p><strong>普通表</strong>:<br>如果时态表中的记录仅仅可以追踪并和它的最新版本,这种表我们称之为普通表,来自数据库 或 HBase 的表可以定义成普通表.</p>
<h4 id="设计初衷"><a href="#设计初衷" class="headerlink" title="设计初衷"></a>设计初衷</h4><h5 id="关联一张版本表"><a href="#关联一张版本表" class="headerlink" title="关联一张版本表"></a>关联一张版本表</h5><p>以订单流关联产品表这个场景举例,orders 表包含了来自 Kafka 的实时订单流,product_changelog 表来自数据库表 products 的 changelog , 产品的价格在数据库表 products 中是随时间实时变化的.<br>SELECT * FROM product_changelog;</p>
<img src="/images/flgl52.png" style="margin-left: 0px; padding-bottom: 10px;">

<p>表 product_changelog 表示数据库表 products不断增长的 changelog, 比如,产品 scooter 在时间点 00:01:00的初始价格是 11.11, 在 12:00:00 的时候涨价到了 12.99, 在 18:00:00 的时候这条产品价格记录被删除.</p>
<p>如果我们想输出 product_changelog 表在 10:00:00 对应的版本,表的内容如下所示:</p>
<img src="/images/flgl53.png" style="margin-left: 0px; padding-bottom: 10px;">

<p>如果我们想输出 product_changelog 表在 13:00:00 对应的版本,表的内容如下所示:</p>
<img src="/images/flgl54.png" style="margin-left: 0px; padding-bottom: 10px;">

<p>上述例子中,products 表的版本是通过 update_time 和 product_id 进行追踪的,product_id 对应 product_changelog 表的主键,update_time 对应事件时间.</p>
<p>在 Flink 中, 这由版本表表示.</p>
<h5 id="关联一张普通表"><a href="#关联一张普通表" class="headerlink" title="关联一张普通表"></a>关联一张普通表</h5><p>另一方面,某些用户案列需要连接变化的维表,该表是外部数据库表.<br>假设 LatestRates 是一个物化的最新汇率表 (比如:一张 HBase 表),LatestRates 总是表示 HBase 表 Rates 的最新内容.<br>我们在 10:15:00 时查询到的内容如下所示:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>:<span class="number">15</span>:<span class="number">00</span> <span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> LatestRates;</span><br><span class="line"></span><br><span class="line">currency  rate</span><br><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span></span><br><span class="line">US Dollar <span class="number">102</span></span><br><span class="line">Euro      <span class="number">114</span></span><br><span class="line">Yen       <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>我们在 11:00:00 时查询到的内容如下所示:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>:<span class="number">00</span>:<span class="number">00</span> <span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> LatestRates;</span><br><span class="line"></span><br><span class="line">currency  rate</span><br><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span></span><br><span class="line">US Dollar <span class="number">102</span></span><br><span class="line">Euro      <span class="number">116</span></span><br><span class="line">Yen       <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>在 Flink 中, 这由普通表表示.</p>
<h4 id="时态表"><a href="#时态表" class="headerlink" title="时态表"></a>时态表</h4><p>Flink 使用主键约束和事件时间来定义一张版本表和版本视图.</p>
<h5 id="声明版本表"><a href="#声明版本表" class="headerlink" title="声明版本表"></a>声明版本表</h5><p>在 Flink 中,定义了主键约束和事件时间属性的表就是版本表.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 定义一张版本表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> product_changelog (</span><br><span class="line"> product_id STRING,</span><br><span class="line"> product_name STRING,</span><br><span class="line"> product_price <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">4</span>),</span><br><span class="line"> update_time <span class="type">TIMESTAMP</span>(<span class="number">3</span>) METADATA <span class="keyword">FROM</span> <span class="string">&#x27;value.source.timestamp&#x27;</span> VIRTUAL,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY(product_id) <span class="keyword">NOT</span> ENFORCED,      <span class="comment">-- (1) 定义主键约束</span></span><br><span class="line"> WATERMARK <span class="keyword">FOR</span> update_time <span class="keyword">AS</span> update_time   <span class="comment">-- (2) 通过 watermark 定义事件时间              </span></span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line"> <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;kafka&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;topic&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;products&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;scan.startup.mode&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;earliest-offset&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;properties.bootstrap.servers&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;localhost:9092&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;value.format&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;debezium-json&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>行 (1) 为表 product_changelog 定义了主键,<br>行 (2) 把 update_time 定义为表 product_changelog 的事件时间,<br>因此 product_changelog 是一张版本表.</p>
<blockquote>
<p>注意: METADATA FROM &#39;value.source.timestamp&#39; VIRTUAL 语法的意思是从每条 changelog 中抽取 changelog 对应的数据库表中操作的执行时间,强烈推荐使用数据库表中操作的 执行时间作为事件时间 ,否则通过时间抽取的版本可能和数据库中的版本不匹配.</p>
</blockquote>
<h5 id="声明版本视图"><a href="#声明版本视图" class="headerlink" title="声明版本视图"></a>声明版本视图</h5><p>Flink 也支持定义版本视图只要一个视图包含主键和事件时间便是一个版本视图.</p>
<p>假设我们有表 RatesHistory 如下所示:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 定义一张 append-only 表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> RatesHistory (</span><br><span class="line">  currency_time <span class="type">TIMESTAMP</span>(<span class="number">3</span>),</span><br><span class="line">  currency STRING,</span><br><span class="line">  rate <span class="type">DECIMAL</span>(<span class="number">38</span>, <span class="number">10</span>),</span><br><span class="line">  WATERMARK <span class="keyword">FOR</span> currency_time <span class="keyword">AS</span> currency_time   <span class="comment">-- 定义事件时间</span></span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line"> <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;kafka&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;topic&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;rates&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;scan.startup.mode&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;earliest-offset&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;properties.bootstrap.servers&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;localhost:9092&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;format&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;json&#x27;</span>                                <span class="comment">-- 普通的 append-only 流</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>表 RatesHistory 代表一个兑换日元货币汇率表(日元汇率为1),该表是不断增长的 append-only 表.<br>例如,欧元 兑换 日元 从 09:00:00 到 10:45:00 的汇率为 114.<br>从 10:45:00 到 11:15:00 的汇率为 116.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> RatesHistory;</span><br><span class="line"></span><br><span class="line">currency_time currency  rate</span><br><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span></span><br><span class="line"><span class="number">09</span>:<span class="number">00</span>:<span class="number">00</span>      US Dollar <span class="number">102</span></span><br><span class="line"><span class="number">09</span>:<span class="number">00</span>:<span class="number">00</span>      Euro      <span class="number">114</span></span><br><span class="line"><span class="number">09</span>:<span class="number">00</span>:<span class="number">00</span>      Yen       <span class="number">1</span></span><br><span class="line"><span class="number">10</span>:<span class="number">45</span>:<span class="number">00</span>      Euro      <span class="number">116</span></span><br><span class="line"><span class="number">11</span>:<span class="number">15</span>:<span class="number">00</span>      Euro      <span class="number">119</span></span><br><span class="line"><span class="number">11</span>:<span class="number">49</span>:<span class="number">00</span>      Pounds    <span class="number">108</span></span><br></pre></td></tr></table></figure>

<p>为了在 RatesHistory 上定义版本表,Flink 支持通过去重查询定义版本视图, 去重查询可以产出一个有序的 changelog 流,去重查询能够推断主键并保留原始数据流的事件时间属性.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> versioned_rates <span class="keyword">AS</span>              </span><br><span class="line"><span class="keyword">SELECT</span> currency, rate, currency_time            <span class="comment">-- (1) `currency_time` 保留了事件时间</span></span><br><span class="line"> <span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span>,</span><br><span class="line">    <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> currency  <span class="comment">-- (2) `currency` 是去重 query 的 unique key,可以作为主键</span></span><br><span class="line">       <span class="keyword">ORDER</span> <span class="keyword">BY</span> currency_time <span class="keyword">DESC</span>) <span class="keyword">AS</span> rowNum </span><br><span class="line">    <span class="keyword">FROM</span> RatesHistory )</span><br><span class="line"><span class="keyword">WHERE</span> rowNum <span class="operator">=</span> <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 视图 `versioned_rates` 将会产出如下的 changelog:</span></span><br><span class="line"></span><br><span class="line">(changelog kind) currency_time currency   rate</span><br><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span>  <span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span></span><br><span class="line"><span class="operator">+</span>(<span class="keyword">INSERT</span>)        <span class="number">09</span>:<span class="number">00</span>:<span class="number">00</span>      US Dollar  <span class="number">102</span></span><br><span class="line"><span class="operator">+</span>(<span class="keyword">INSERT</span>)        <span class="number">09</span>:<span class="number">00</span>:<span class="number">00</span>      Euro       <span class="number">114</span></span><br><span class="line"><span class="operator">+</span>(<span class="keyword">INSERT</span>)        <span class="number">09</span>:<span class="number">00</span>:<span class="number">00</span>      Yen        <span class="number">1</span></span><br><span class="line"><span class="operator">+</span>(UPDATE_AFTER)  <span class="number">10</span>:<span class="number">45</span>:<span class="number">00</span>      Euro       <span class="number">116</span></span><br><span class="line"><span class="operator">+</span>(UPDATE_AFTER)  <span class="number">11</span>:<span class="number">15</span>:<span class="number">00</span>      Euro       <span class="number">119</span></span><br><span class="line"><span class="operator">+</span>(<span class="keyword">INSERT</span>)        <span class="number">11</span>:<span class="number">49</span>:<span class="number">00</span>      Pounds     <span class="number">108</span></span><br></pre></td></tr></table></figure>

<p>行 (1) 保留了事件时间作为视图 versioned_rates 的事件时间,<br>行 (2) 使得视图 versioned_rates 有了主键, 因此视图 versioned_rates 是一个版本视图.</p>
<p>视图中的去重 query 会被 Flink 优化并高效地产出 changelog stream, 产出的 changelog 保留了主键约束和事件时间.</p>
<p>如果我们想输出 versioned_rates 表在 11:00:00 对应的版本,表的内容如下所示:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">currency_time currency   rate  </span><br><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span></span><br><span class="line"><span class="number">09</span>:<span class="number">00</span>:<span class="number">00</span>      US Dollar  <span class="number">102</span></span><br><span class="line"><span class="number">09</span>:<span class="number">00</span>:<span class="number">00</span>      Yen        <span class="number">1</span></span><br><span class="line"><span class="number">10</span>:<span class="number">45</span>:<span class="number">00</span>      Euro       <span class="number">116</span></span><br></pre></td></tr></table></figure>
<p>如果我们想输出 versioned_rates 表在 12:00:00 对应的版本,表的内容如下所示:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">currency_time currency   rate  </span><br><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span></span><br><span class="line"><span class="number">09</span>:<span class="number">00</span>:<span class="number">00</span>      US Dollar  <span class="number">102</span></span><br><span class="line"><span class="number">09</span>:<span class="number">00</span>:<span class="number">00</span>      Yen        <span class="number">1</span></span><br><span class="line"><span class="number">10</span>:<span class="number">45</span>:<span class="number">00</span>      Euro       <span class="number">119</span></span><br><span class="line"><span class="number">11</span>:<span class="number">49</span>:<span class="number">00</span>      Pounds     <span class="number">108</span></span><br></pre></td></tr></table></figure>

<h5 id="声明普通表"><a href="#声明普通表" class="headerlink" title="声明普通表"></a>声明普通表</h5><p>普通表的声明和 Flink 建表 DDL 一致.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用 DDL 定义一张 HBase 表,然后我们可以在 SQL 中将其当作一张时态表使用</span></span><br><span class="line"><span class="comment">-- &#x27;currency&#x27; 列是 HBase 表中的 rowKey</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> LatestRates (   </span><br><span class="line">   currency STRING,   </span><br><span class="line">   fam1 <span class="type">ROW</span><span class="operator">&lt;</span>rate <span class="keyword">DOUBLE</span><span class="operator">&gt;</span>   </span><br><span class="line">) <span class="keyword">WITH</span> (   </span><br><span class="line">  <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;hbase-1.4&#x27;</span>,   </span><br><span class="line">  <span class="string">&#x27;table-name&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;rates&#x27;</span>,   </span><br><span class="line">  <span class="string">&#x27;zookeeper.quorum&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;localhost:2181&#x27;</span>   </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>注意:理论上讲任意都能用作时态表并在基于处理时间的时态表 Join 中使用,但当前支持作为时态表的普通表必须实现接口 LookupableTableSource.<br>接口 LookupableTableSource 的实例只能作为时态表用于基于处理时间的时态 Join .</p>
<p>通过 LookupableTableSource 定义的表意味着该表具备了在运行时通过一个或多个 key 去查询外部存储系统的能力,当前支持在 基于处理时间的时态表 join 中使用的表包括 JDBC, HBase 和 Hive.</p>
<p>在基于处理时间的时态表 Join 中支持任意表作为时态表会在不远的将来支持.</p>
<h3 id="时态表函数"><a href="#时态表函数" class="headerlink" title="时态表函数"></a>时态表函数</h3><p>时态表函数提供对特定时间点时态表版本的访问.<br>为了访问时态表中的数据,必须传递一个时间属性,该属性确定将返回的表的版本.<br>Flink 使用表函数的 SQL 语法来提供一种表达方式.</p>
<p>与版本化表不同,时态表函数只能在仅附加流之上定义——它不支持更改日志输入.<br>此外,不能在纯 SQL DDL 中定义时态表函数.</p>
<h4 id="定义时态表函数"><a href="#定义时态表函数" class="headerlink" title="定义时态表函数"></a>定义时态表函数</h4><p>可以使用Table API在仅附加流之上定义时态表函数.<br>该表注册了一个或多个关键列,以及用于版本控制的时间属性.</p>
<p>假设我们有一个仅附加的汇率表,我们希望将其注册为时态表函数.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> currency_rates;</span><br><span class="line"></span><br><span class="line">update_time   currency   rate</span><br><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span>  <span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span></span><br><span class="line"><span class="number">09</span>:<span class="number">00</span>:<span class="number">00</span>      Yen        <span class="number">102</span></span><br><span class="line"><span class="number">09</span>:<span class="number">00</span>:<span class="number">00</span>      Euro       <span class="number">114</span></span><br><span class="line"><span class="number">09</span>:<span class="number">00</span>:<span class="number">00</span>      USD        <span class="number">1</span></span><br><span class="line"><span class="number">11</span>:<span class="number">15</span>:<span class="number">00</span>      Euro       <span class="number">119</span></span><br><span class="line"><span class="number">11</span>:<span class="number">49</span>:<span class="number">00</span>      Pounds     <span class="number">108</span></span><br></pre></td></tr></table></figure>

<p>使用 Table API,我们可以使用currencykey 和update_time版本控制时间属性来注册这个流.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TemporalTableFunction rates = tEnv</span><br><span class="line">  .from(<span class="string">&quot;currency_rates&quot;</span>).</span><br><span class="line">  .createTemporalTableFunction(<span class="string">&quot;update_time&quot;</span>, <span class="string">&quot;currency&quot;</span>);</span><br><span class="line"></span><br><span class="line">tEnv.registerFunction(<span class="string">&quot;rates&quot;</span>, rates);                                                        </span><br></pre></td></tr></table></figure>

<h4 id="时态表函数连接-Join"><a href="#时态表函数连接-Join" class="headerlink" title="时态表函数连接(Join)"></a>时态表函数连接(Join)</h4><p>一旦定义,时态表函数将用作标准表函数.<br>仅追加表(左侧输入/探测侧)可以与临时表(右侧输入/构建侧)连接,即随时间变化并跟踪其变化的表,以检索键的值,就像它在特定的时间点.</p>
<p>orders考虑一个以不同货币跟踪客户订单的仅附加表.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders;</span><br><span class="line"></span><br><span class="line">order_time amount currency</span><br><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span></span><br><span class="line"><span class="number">10</span>:<span class="number">15</span>        <span class="number">2</span>    Euro</span><br><span class="line"><span class="number">10</span>:<span class="number">30</span>        <span class="number">1</span>    USD</span><br><span class="line"><span class="number">10</span>:<span class="number">32</span>       <span class="number">50</span>    Yen</span><br><span class="line"><span class="number">10</span>:<span class="number">52</span>        <span class="number">3</span>    Euro</span><br><span class="line"><span class="number">11</span>:<span class="number">04</span>        <span class="number">5</span>    USD</span><br></pre></td></tr></table></figure>

<p>鉴于这些表格,我们希望将订单转换为通用货币——美元.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"> <span class="built_in">SUM</span>(amount <span class="operator">*</span> rate) <span class="keyword">AS</span> amount</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"> orders,</span><br><span class="line"> <span class="keyword">LATERAL</span> <span class="keyword">TABLE</span> (rates(order_time))</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"> rates.currency <span class="operator">=</span> orders.currency</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Table result = orders</span><br><span class="line">    .joinLateral($(<span class="string">&quot;rates(order_time)&quot;</span>), $(<span class="string">&quot;orders.currency = rates.currency&quot;</span>))</span><br><span class="line">    .select($(<span class="string">&quot;(o_amount * r_rate).sum as amount&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="Performance-Tuning-流式聚合"><a href="#Performance-Tuning-流式聚合" class="headerlink" title="Performance Tuning(流式聚合)"></a>Performance Tuning(流式聚合)</h3><p>SQL 是数据分析中使用最广泛的语言.<br>Flink Table API 和 SQL 使用户能够以更少的时间和精力定义高效的流分析应用程序.<br>此外,Flink Table API 和 SQL 是高效优化过的,它集成了许多查询优化和算子优化.<br>但并不是所有的优化都是默认开启的,因此对于某些工作负载,可以通过打开某些选项来提高性能.</p>
<h4 id="MiniBatch-聚合"><a href="#MiniBatch-聚合" class="headerlink" title="MiniBatch 聚合"></a>MiniBatch 聚合</h4><p>默认情况下,无界聚合算子是逐条处理输入的记录,即:</p>
<ol>
<li>从状态中读取累加器,</li>
<li>累加/撤回记录至累加器,</li>
<li>将累加器写回状态,</li>
<li>下一条记录将再次从(1)开始处理.</li>
</ol>
<p>这种处理模式可能会增加 StateBackend 开销(尤其是对于 RocksDB StateBackend ).<br>此外,生产中非常常见的数据倾斜会使这个问题恶化,并且容易导致 job 发生反压.</p>
<p>MiniBatch 聚合的核心思想是将一组输入的数据缓存在聚合算子内部的缓冲区中.<br>当输入的数据被触发处理时,每个 key 只需一个操作即可访问状态.<br>这样可以大大减少状态开销并获得更好的吞吐量.<br>但是,这可能会增加一些延迟,因为它会缓冲一些记录而不是立即处理它们.<br>这是吞吐量和延迟之间的权衡.</p>
<p>下图说明了 mini-batch 聚合如何减少状态操作.</p>
<img src="/images/flgl55.png" width="400" style="margin-left: 0px; padding-bottom: 10px;">

<p>默认情况下,对于无界聚合算子来说,mini-batch 优化是被禁用的.<br>开启这项优化,需要设置选项 <code>table.exec.mini-batch.enabled</code>/<code>table.exec.mini-batch.allow-latency</code>/<code>table.exec.mini-batch.size</code>.</p>
<p>MiniBatch optimization is always enabled for Window TVF Aggregation, regardless of the above configuration. Window TVF aggregation buffer records in managed memory instead of JVM Heap, so there is no risk of overloading GC or OOM issues.</p>
<p>下面的例子显示如何启用这些选项.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instantiate table environment</span></span><br><span class="line">TableEnvironment tEnv = ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// access flink configuration</span></span><br><span class="line">TableConfig configuration = tEnv.getConfig();</span><br><span class="line"><span class="comment">// set low-level key-value options</span></span><br><span class="line">configuration.set(<span class="string">&quot;table.exec.mini-batch.enabled&quot;</span>, <span class="string">&quot;true&quot;</span>); <span class="comment">// enable mini-batch optimization</span></span><br><span class="line">configuration.set(<span class="string">&quot;table.exec.mini-batch.allow-latency&quot;</span>, <span class="string">&quot;5 s&quot;</span>); <span class="comment">// use 5 seconds to buffer input records</span></span><br><span class="line">configuration.set(<span class="string">&quot;table.exec.mini-batch.size&quot;</span>, <span class="string">&quot;5000&quot;</span>); <span class="comment">// the maximum number of records can be buffered by each aggregate operator task</span></span><br></pre></td></tr></table></figure>

<h4 id="Local-Global-聚合"><a href="#Local-Global-聚合" class="headerlink" title="Local-Global 聚合"></a>Local-Global 聚合</h4><p>Local-Global 聚合是为解决数据倾斜问题提出的,通过将一组聚合分为两个阶段,首先在上游进行本地聚合,然后在下游进行全局聚合,类似于 MapReduce 中的 Combine + Reduce 模式.<br>例如,就以下 SQL 而言:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> color, <span class="built_in">sum</span>(id)</span><br><span class="line"><span class="keyword">FROM</span> T</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> color</span><br></pre></td></tr></table></figure>

<p>数据流中的记录可能会倾斜,因此某些聚合算子的实例必须比其他实例处理更多的记录,这会产生热点问题.<br>本地聚合可以将一定数量具有相同 key 的输入数据累加到单个累加器中.<br>全局聚合将仅接收 reduce 后的累加器,而不是大量的原始输入数据.<br>这可以大大减少网络 shuffle 和状态访问的成本.<br>每次本地聚合累积的输入数据量基于 mini-batch 间隔.<br>这意味着 local-global 聚合依赖于启用了 mini-batch 优化.</p>
<p>下图显示了 local-global 聚合如何提高性能.</p>
<img src="/images/flgl56.png" style="margin-left: 0px; padding-bottom: 10px;">

<p>下面的例子显示如何启用 local-global 聚合.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instantiate table environment</span></span><br><span class="line">TableEnvironment tEnv = ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// access flink configuration</span></span><br><span class="line">Configuration configuration = tEnv.getConfig().getConfiguration();</span><br><span class="line"><span class="comment">// set low-level key-value options</span></span><br><span class="line">configuration.setString(<span class="string">&quot;table.exec.mini-batch.enabled&quot;</span>, <span class="string">&quot;true&quot;</span>); <span class="comment">// local-global aggregation depends on mini-batch is enabled</span></span><br><span class="line">configuration.setString(<span class="string">&quot;table.exec.mini-batch.allow-latency&quot;</span>, <span class="string">&quot;5 s&quot;</span>);</span><br><span class="line">configuration.setString(<span class="string">&quot;table.exec.mini-batch.size&quot;</span>, <span class="string">&quot;5000&quot;</span>);</span><br><span class="line">configuration.setString(<span class="string">&quot;table.optimizer.agg-phase-strategy&quot;</span>, <span class="string">&quot;TWO_PHASE&quot;</span>); <span class="comment">// enable two-phase, i.e. local-global aggregation</span></span><br></pre></td></tr></table></figure>

<h4 id="拆分-distinct-聚合"><a href="#拆分-distinct-聚合" class="headerlink" title="拆分 distinct 聚合"></a>拆分 distinct 聚合</h4><p>Local-Global 优化可有效消除常规聚合的数据倾斜,例如 SUM/COUNT/MAX/MIN/AVG.<br>但是在处理 distinct 聚合时,其性能并不令人满意.</p>
<p>例如,如果我们要分析今天有多少唯一用户登录.<br>我们可能有以下查询:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">day</span>, <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> user_id)</span><br><span class="line"><span class="keyword">FROM</span> T</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">day</span></span><br></pre></td></tr></table></figure>

<p>如果 distinct key (即 user_id)的值分布稀疏,则 COUNT DISTINCT 不适合减少数据.<br>即使启用了 local-global 优化也没有太大帮助.<br>因为累加器仍然包含几乎所有原始记录,并且全局聚合将成为瓶颈(大多数繁重的累加器由一个任务处理,即同一天).</p>
<p>这个优化的想法是将不同的聚合(例如 COUNT(DISTINCT col))分为两个级别.<br>第一次聚合由 group key 和额外的 bucket key 进行 shuffle.<br>bucket key 是使用 <code>HASH_CODE(distinct_key) % BUCKET_NUM</code> 计算的.<br>BUCKET_NUM 默认为1024,可以通过 <code>table.optimizer.distinct-agg.split.bucket-num</code> 选项进行配置.<br>第二次聚合是由原始 group key 进行 shuffle,并使用 SUM 聚合来自不同 buckets 的 COUNT DISTINCT 值.<br>由于相同的 distinct key 将仅在同一 bucket 中计算,因此转换是等效的.<br>bucket key 充当附加 group key 的角色,以分担 group key 中热点的负担.<br>bucket key 使 job 具有可伸缩性来解决不同聚合中的数据倾斜/热点.</p>
<p>拆分 distinct 聚合后,以上查询将被自动改写为以下查询:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">day</span>, <span class="built_in">SUM</span>(cnt)</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="keyword">day</span>, <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> user_id) <span class="keyword">as</span> cnt</span><br><span class="line">  <span class="keyword">FROM</span> T</span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">day</span>, <span class="built_in">MOD</span>(HASH_CODE(user_id), <span class="number">1024</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">day</span></span><br></pre></td></tr></table></figure>

<p>下图显示了拆分 distinct 聚合如何提高性能(假设颜色表示 days,字母表示 user_id).</p>
<img src="/images/flgl57.png" style="margin-left: 0px; padding-bottom: 10px;">

<p>注意:上面是可以从这个优化中受益的最简单的示例.<br>除此之外,Flink 还支持拆分更复杂的聚合查询,例如,多个具有不同 distinct key (例如 COUNT(DISTINCT a), SUM(DISTINCT b) )的 distinct 聚合,可以与其他非 distinct 聚合(例如 SUM/MAX/MIN/COUNT )一起使用.</p>
<p>注意 当前,拆分优化不支持包含用户定义的 AggregateFunction 聚合.</p>
<p>下面的例子显示了如何启用拆分 distinct 聚合优化.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instantiate table environment</span></span><br><span class="line">TableEnvironment tEnv = ...;</span><br><span class="line"></span><br><span class="line">tEnv.getConfig()</span><br><span class="line"> .set(<span class="string">&quot;table.optimizer.distinct-agg.split.enabled&quot;</span>, <span class="string">&quot;true&quot;</span>);  <span class="comment">// enable distinct agg split</span></span><br></pre></td></tr></table></figure>

<h3 id="在-distinct-聚合上使用-FILTER-修饰符"><a href="#在-distinct-聚合上使用-FILTER-修饰符" class="headerlink" title="在 distinct 聚合上使用 FILTER 修饰符"></a>在 distinct 聚合上使用 FILTER 修饰符</h3><p>在某些情况下,用户可能需要从不同维度计算 UV(独立访客)的数量,例如来自 Android 的 UV/iPhone 的 UV/Web 的 UV 和总 UV.<br>很多人会选择 CASE WHEN,例如:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">day</span>,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> user_id) <span class="keyword">AS</span> total_uv,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">CASE</span> <span class="keyword">WHEN</span> flag <span class="keyword">IN</span> (<span class="string">&#x27;android&#x27;</span>, <span class="string">&#x27;iphone&#x27;</span>) <span class="keyword">THEN</span> user_id <span class="keyword">ELSE</span> <span class="keyword">NULL</span> <span class="keyword">END</span>) <span class="keyword">AS</span> app_uv,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">CASE</span> <span class="keyword">WHEN</span> flag <span class="keyword">IN</span> (<span class="string">&#x27;wap&#x27;</span>, <span class="string">&#x27;other&#x27;</span>) <span class="keyword">THEN</span> user_id <span class="keyword">ELSE</span> <span class="keyword">NULL</span> <span class="keyword">END</span>) <span class="keyword">AS</span> web_uv</span><br><span class="line"><span class="keyword">FROM</span> T</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">day</span></span><br></pre></td></tr></table></figure>

<p>但是,在这种情况下,建议使用 FILTER 语法而不是 CASE WHEN.<br>因为 FILTER 更符合 SQL 标准,并且能获得更多的性能提升.<br>FILTER 是用于聚合函数的修饰符,用于限制聚合中使用的值.<br>将上面的示例替换为 FILTER 修饰符,如下所示:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">day</span>,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> user_id) <span class="keyword">AS</span> total_uv,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> user_id) <span class="keyword">FILTER</span> (<span class="keyword">WHERE</span> flag <span class="keyword">IN</span> (<span class="string">&#x27;android&#x27;</span>, <span class="string">&#x27;iphone&#x27;</span>)) <span class="keyword">AS</span> app_uv,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> user_id) <span class="keyword">FILTER</span> (<span class="keyword">WHERE</span> flag <span class="keyword">IN</span> (<span class="string">&#x27;wap&#x27;</span>, <span class="string">&#x27;other&#x27;</span>)) <span class="keyword">AS</span> web_uv</span><br><span class="line"><span class="keyword">FROM</span> T</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">day</span></span><br></pre></td></tr></table></figure>

<p>Flink SQL 优化器可以识别相同的 distinct key 上的不同过滤器参数.<br>例如,在上面的示例中,三个 COUNT DISTINCT 都在 user_id 一列上.<br>Flink 可以只使用一个共享状态实例,而不是三个状态实例,以减少状态访问和状态大小.<br>在某些工作负载下,可以获得显著的性能提升.</p>
<h2 id="数据类型-Data-Types"><a href="#数据类型-Data-Types" class="headerlink" title="数据类型(Data Types)"></a>数据类型(Data Types)</h2><p>Flink SQL 有一组丰富的原生数据类型可供用户使用.</p>
<h3 id="Data-Type"><a href="#Data-Type" class="headerlink" title="Data Type"></a>Data Type</h3><p>数据类型描述了表生态系统中值的逻辑类型.<br>它可用于声明操作的输入和/或输出类型.</p>
<p>Flink 的数据类型类似于 SQL 标准的数据类型术语,但也包含有关值的可空性的信息,以有效处理标量表达式.</p>
<p>数据类型的示例有:</p>
<ol>
<li>INT</li>
<li>INT NOT NULL</li>
<li>INTERVAL DAY TO SECOND(3)</li>
<li><code>ROW&lt;myField ARRAY&lt;BOOLEAN&gt;, myOtherField TIMESTAMP(3)&gt;</code></li>
</ol>
<h4 id="Table-API-中的数据类型"><a href="#Table-API-中的数据类型" class="headerlink" title="Table API 中的数据类型"></a>Table API 中的数据类型</h4><p>基于 JVM 的 API 的用户使用 Table API 内的实例org.apache.flink.table.types.DataType或在定义连接器/目录或用户定义的函数时.<br>一个DataType实例有两个职责:</p>
<ol>
<li>逻辑类型的声明并不意味着传输或存储的具体物理表示,但定义了基于 JVM/Python 语言和表生态系统之间的边界.</li>
<li>可选: 向规划器提供有关数据物理表示的提示,这在其他 API 的边缘很有用.</li>
</ol>
<p>对于基于 JVM 的语言,所有预定义的数据类型都可以在org.apache.flink.table.api.DataTypes.</p>
<p>建议在您的表格程序中添加星型导入,以获得流畅的 API:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.apache.flink.table.api.DataTypes.*;</span><br><span class="line">DataType t = INTERVAL(DAY(), SECOND(<span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<h5 id="物理提示-Physical-Hints"><a href="#物理提示-Physical-Hints" class="headerlink" title="物理提示(Physical Hints)"></a>物理提示(Physical Hints)</h5><p>在基于 SQL 的类型系统结束并且需要特定于编程的数据类型的表生态系统的边缘需要物理提示.<br>提示指示实现所期望的数据格式.</p>
<p>例如,数据源可以表示它使用类而不是使用默认值来为逻辑TIMESTAMPs生成值.<br>使用此信息,运行时能够将生成的类转换为其内部数据格式.<br>作为回报,数据接收器可以声明它从运行时使用的数据格式.<br>java.sql.Timestampjava.time.LocalDateTime</p>
<p>以下是一些如何声明桥接转换类的示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tell the runtime to not produce or consume java.time.LocalDateTime instances</span></span><br><span class="line"><span class="comment">// but java.sql.Timestamp</span></span><br><span class="line">DataType t = DataTypes.TIMESTAMP(<span class="number">3</span>).bridgedTo(java.sql.Timestamp.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// tell the runtime to not produce or consume boxed integer arrays</span></span><br><span class="line"><span class="comment">// but primitive int arrays</span></span><br><span class="line">DataType t = DataTypes.ARRAY(DataTypes.INT().notNull()).bridgedTo(<span class="keyword">int</span>[].class);</span><br></pre></td></tr></table></figure>

<p>请注意,物理提示通常仅在 API 扩展时才需要.<br>预定义源/汇/功能的用户不需要定义此类提示.<br>表格程序中的提示(例如field.cast(TIMESTAMP(3).bridgedTo(Timestamp.class)))被忽略.</p>
<h3 id="数据类型列表"><a href="#数据类型列表" class="headerlink" title="数据类型列表"></a>数据类型列表</h3><p>本节列出了所有预定义的数据类型.<br>对于基于 JVM 的 Table API,这些类型也可以在<code>org.apache.flink.table.api.DataTypes</code>.<br>默认规划器支持以下 SQL 类型集:</p>
<table>
<thead>
<tr>
<th>Data Type</th>
<th>数据类型备注</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR</td>
<td></td>
</tr>
<tr>
<td>VARCHAR</td>
<td></td>
</tr>
<tr>
<td>STRING</td>
<td></td>
</tr>
<tr>
<td>BOOLEAN</td>
<td></td>
</tr>
<tr>
<td>BINARY</td>
<td></td>
</tr>
<tr>
<td>VARBINARY</td>
<td></td>
</tr>
<tr>
<td>BYTES</td>
<td></td>
</tr>
<tr>
<td>DECIMAL</td>
<td>支持固定精度和比例</td>
</tr>
<tr>
<td>TINYINT</td>
<td></td>
</tr>
<tr>
<td>SMALLINT</td>
<td></td>
</tr>
<tr>
<td>INTEGER</td>
<td></td>
</tr>
<tr>
<td>BIGINT</td>
<td></td>
</tr>
<tr>
<td>FLOAT</td>
<td></td>
</tr>
<tr>
<td>DOUBLE</td>
<td></td>
</tr>
<tr>
<td>DATE</td>
<td></td>
</tr>
<tr>
<td>TIME</td>
<td>仅支持精度为0</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td></td>
</tr>
<tr>
<td>TIMESTAMP_LTZ</td>
<td></td>
</tr>
<tr>
<td>INTERVAL</td>
<td>Supports only interval of MONTH and SECOND(3)</td>
</tr>
<tr>
<td>ARRAY</td>
<td></td>
</tr>
<tr>
<td>MULTISET</td>
<td></td>
</tr>
<tr>
<td>MAP</td>
<td></td>
</tr>
<tr>
<td>ROW</td>
<td></td>
</tr>
<tr>
<td>RAW</td>
<td></td>
</tr>
<tr>
<td>Structured types</td>
<td>仅在用户定义的函数中公开</td>
</tr>
</tbody></table>
<h4 id="Character-Strings-字符串"><a href="#Character-Strings-字符串" class="headerlink" title="Character Strings(字符串)"></a>Character Strings(字符串)</h4><h5 id="CHAR"><a href="#CHAR" class="headerlink" title="CHAR"></a>CHAR</h5><p>定长字符串的数据类型.</p>
<p>CHAR<br>CHAR(n)</p>
<p>#java<br>DataTypes.CHAR(n)</p>
<p>可以使用CHAR(n) where n是代码点数来声明类型.<br>n必须有一个介于1 和2,147,483,647(包括两者)之间的值.<br>如果没有指定长度,n则等于1.</p>
<h5 id="VARCHAR-STRING"><a href="#VARCHAR-STRING" class="headerlink" title="VARCHAR / STRING"></a>VARCHAR / STRING</h5><p>变长字符串的数据类型.</p>
<p>VARCHAR<br>VARCHAR(n)<br>STRING</p>
<p>#java<br>DataTypes.VARCHAR(n)<br>DataTypes.STRING()</p>
<p>可以使用VARCHAR(n) where n是最大代码点数来声明类型.<br>n必须有一个介于1和2,147,483,647(包括两者)之间的值.<br>如果没有指定长度,n则等于1.</p>
<p>STRING是 的同义词VARCHAR(2147483647).</p>
<h4 id="Binary-Strings-二进制字符串"><a href="#Binary-Strings-二进制字符串" class="headerlink" title="Binary Strings(二进制字符串)"></a>Binary Strings(二进制字符串)</h4><h5 id="BINARY"><a href="#BINARY" class="headerlink" title="BINARY"></a>BINARY</h5><p>固定长度二进制字符串的数据类型(=字节序列).</p>
<p>BINARY<br>BINARY(n)</p>
<p>#java<br>DataTypes.BINARY(n)</p>
<p>可以使用BINARY(n) where n是字节数来声明类型.<br>n必须有一个介于1和2,147,483,647(包括两者)之间的值.<br>如果没有指定长度,n则等于1.</p>
<h5 id="VARBINARY-BYTES"><a href="#VARBINARY-BYTES" class="headerlink" title="VARBINARY / BYTES"></a>VARBINARY / BYTES</h5><p>可变长度二进制字符串的数据类型(=字节序列).</p>
<p>VARBINARY<br>VARBINARY(n)<br>BYTES</p>
<p>#java<br>DataTypes.VARBINARY(n)<br>DataTypes.BYTES()</p>
<p>可以使用VARBINARY(n) where n是最大字节数来声明类型.<br>n必须有一个介于1和2,147,483,647(包括两者)之间的值.<br>如果没有指定长度,n则等于1.</p>
<p>BYTES是 的同义词VARBINARY(2147483647).</p>
<h4 id="Exact-Numerics-精确数字"><a href="#Exact-Numerics-精确数字" class="headerlink" title="Exact Numerics(精确数字)"></a>Exact Numerics(精确数字)</h4><h5 id="DECIMAL"><a href="#DECIMAL" class="headerlink" title="DECIMAL"></a>DECIMAL</h5><p>具有固定精度和小数位数的十进制数的数据类型.</p>
<p>DECIMAL<br>DECIMAL(p)<br>DECIMAL(p, s)</p>
<p>DEC<br>DEC(p)<br>DEC(p, s)</p>
<p>NUMERIC<br>NUMERIC(p)<br>NUMERIC(p, s)</p>
<p>#java<br>DataTypes.DECIMAL(p, s)</p>
<p>可以使用DECIMAL(p, s) where p是数字中的位数 ( precision ) 和s是数字中小数点右侧的位数 ( scale ) 来声明类型.<br>p必须有一个介于1和38(包括两者)之间的值.<br>s 必须有一个介于0和p(包括两者)之间的值.<br>p的默认值为10.<br>s的默认值为0.</p>
<p>NUMERIC(p, s)并且DEC(p, s)是这种类型的同义词.</p>
<h5 id="TINYINT"><a href="#TINYINT" class="headerlink" title="TINYINT"></a>TINYINT</h5><p>1 字节有符号整数的数据类型,其值从-128到127.</p>
<p>TINYINT</p>
<p>#java<br>DataTypes.TINYINT()</p>
<h5 id="SMALLINT"><a href="#SMALLINT" class="headerlink" title="SMALLINT"></a>SMALLINT</h5><p>-32,768值从到的 2 字节有符号整数的数据类型32,767.</p>
<p>SMALLINT</p>
<p>#java<br>DataTypes.SMALLINT()</p>
<h5 id="INT"><a href="#INT" class="headerlink" title="INT"></a>INT</h5><p>4 字节有符号整数的数据类型,其值从-2,147,483,648到2,147,483,647.</p>
<p>INT</p>
<p>INTEGER</p>
<p>INTEGER是这种类型的同义词.</p>
<h5 id="BIGINT"><a href="#BIGINT" class="headerlink" title="BIGINT"></a>BIGINT</h5><p>一个 8 字节有符号整数的数据类型,其值从-9,223,372,036,854,775,808到 9,223,372,036,854,775,807.</p>
<p>BIGINT</p>
<h4 id="Approximate-Numerics-近似数字"><a href="#Approximate-Numerics-近似数字" class="headerlink" title="Approximate Numerics(近似数字)"></a>Approximate Numerics(近似数字)</h4><h5 id="FLOAT"><a href="#FLOAT" class="headerlink" title="FLOAT"></a>FLOAT</h5><p>4 字节单精度浮点数的数据类型.<br>与 SQL 标准相比,该类型不带参数.</p>
<p>FLOAT</p>
<h5 id="DOUBLE"><a href="#DOUBLE" class="headerlink" title="DOUBLE"></a>DOUBLE</h5><p>8 字节双精度浮点数的数据类型.</p>
<p>DOUBLE<br>DOUBLE PRECISION</p>
<p>DOUBLE PRECISION是这种类型的同义词.</p>
<h4 id="Date-and-Time-日期和时间"><a href="#Date-and-Time-日期和时间" class="headerlink" title="Date and Time(日期和时间)"></a>Date and Time(日期和时间)</h4><h5 id="DATE"><a href="#DATE" class="headerlink" title="DATE"></a>DATE</h5><p>日期的数据类型,包含year-month-day从0000-01-01 到的值9999-12-31.<br>与 SQL 标准相比,范围从 year 开始0000.</p>
<p>DATE</p>
<h5 id="TIME"><a href="#TIME" class="headerlink" title="TIME"></a>TIME</h5><p>不带时区的时间数据类型,<code>hour:minute:second[.fractional]</code>精度高达纳秒,值范围从00:00:00.000000000到 23:59:59.999999999.</p>
<p>SQL/Java/Scala<br>与 SQL 标准相比,不支持闰秒 (23:59:60和23:59:61),因为语义更接近java.time.LocalTime. 未提供带时区的时间.</p>
<p>TIME<br>TIME(p)</p>
<p>TIME(p)可以使用where p是小数秒的位数(精度)来声明该类型.<br>p必须有一个介于0和9(包括两者)之间的值.<br>如果未指定精度,p则等于0.</p>
<h5 id="TIMESTAMP"><a href="#TIMESTAMP" class="headerlink" title="TIMESTAMP"></a>TIMESTAMP</h5><p>不带时区的时间戳的数据类型,由<code>year-month-day hour:minute:second[.fractional]</code> 高达纳秒精度和范围从0000-01-01 00:00:00.000000000到 的 值组成9999-12-31 23:59:59.999999999.</p>
<p>TIMESTAMP<br>TIMESTAMP(p)</p>
<p>TIMESTAMP WITHOUT TIME ZONE<br>TIMESTAMP(p) WITHOUT TIME ZONE</p>
<p>TIMESTAMP(p)可以使用where p是小数秒的位数(精度)来声明该类型.<br>p必须有一个介于0和9(包括两者)之间的值.<br>如果未指定精度,p则等于6.</p>
<p>TIMESTAMP(p) WITHOUT TIME ZONE是这种类型的同义词.</p>
<h5 id="TIMESTAMP-WITH-TIME-ZONE"><a href="#TIMESTAMP-WITH-TIME-ZONE" class="headerlink" title="TIMESTAMP WITH TIME ZONE"></a>TIMESTAMP WITH TIME ZONE</h5><p>时间戳的数据类型,时区由<code>year-month-day hour:minute:second[.fractional]</code> zone 高达纳秒的精度和从0000-01-01 00:00:00.000000000 +14:59到 的 值组成9999-12-31 23:59:59.999999999 -14:59.</p>
<p>与 相比TIMESTAMP_LTZ,时区偏移信息物理存储在每个数据中.<br>它单独用于每次计算/可视化或与外部系统的通信.</p>
<p>TIMESTAMP WITH TIME ZONE<br>TIMESTAMP(p) WITH TIME ZONE</p>
<h5 id="TIMESTAMP-LTZ"><a href="#TIMESTAMP-LTZ" class="headerlink" title="TIMESTAMP_LTZ"></a>TIMESTAMP_LTZ</h5><p>具有本地时区的时间戳的数据类型,由<code>year-month-day hour:minute:second[.fractional]</code> zone 高达纳秒精度和范围从0000-01-01 00:00:00.000000000 +14:59到 的 值组成9999-12-31 23:59:59.999999999 -14:59.</p>
<p>不支持闰秒 (23:59:60和23:59:61),因为语义更接近java.time.OffsetDateTime.</p>
<p>与 相比TIMESTAMP WITH TIME ZONE,时区偏移信息并非物理存储在每个数据中.<br>相反,该类型假定java.time.Instant表生态系统边缘的 UTC 时区语义.<br>每个数据都在当前会话中配置的本地时区进行解释,以进行计算和可视化.</p>
<p>此类型通过允许根据配置的会话时区解释 UTC 时间戳来填补无时区和时区强制时间戳类型之间的空白.</p>
<p>TIMESTAMP_LTZ<br>TIMESTAMP_LTZ(p)</p>
<p>TIMESTAMP WITH LOCAL TIME ZONE<br>TIMESTAMP(p) WITH LOCAL TIME ZONE</p>
<p>TIMESTAMP_LTZ(p)可以使用where p是小数秒的位数(精度)来声明该类型.<br>p必须有一个介于0和9 (包括两者)之间的值.<br>如果未指定精度,p则等于6.</p>
<p>TIMESTAMP(p) WITH LOCAL TIME ZONE是这种类型的同义词.</p>
<h5 id="INTERVAL-YEAR-TO-MONTH"><a href="#INTERVAL-YEAR-TO-MONTH" class="headerlink" title="INTERVAL YEAR TO MONTH"></a>INTERVAL YEAR TO MONTH</h5><p>一组年月间隔类型的数据类型.</p>
<p>必须将类型参数化为以下分辨率之一:<br>interval of years,<br>interval of years to months,<br>or interval of months.</p>
<p>年-月的间隔由+years-months从-9999-11到 的值组成+9999-11.</p>
<p>所有类型的分辨率的值表示都是相同的.<br>例如,50 个月的间隔总是以年到月的间隔格式表示(默认年份精度):+04-02.</p>
<p>INTERVAL YEAR<br>INTERVAL YEAR(p)<br>INTERVAL YEAR(p) TO MONTH<br>INTERVAL MONTH</p>
<p>可以使用上述组合声明类型,其中p是年份的位数(年份精度).<br>p必须有一个介于1和4(包括两者)之间的值.<br>如果未指定年份精度,p则等于2.</p>
<h5 id="INTERVAL-DAY-TO-SECOND"><a href="#INTERVAL-DAY-TO-SECOND" class="headerlink" title="INTERVAL DAY TO SECOND"></a>INTERVAL DAY TO SECOND</h5><p>一组日时间间隔类型的数据类型.<br>必须将类型参数化为以下分辨率之一,精度最高可达纳秒:<br>interval of days,<br>interval of days to hours,<br>interval of days to minutes,<br>interval of days to seconds,<br>interval of hours,<br>interval of hours to minutes,<br>interval of hours to seconds,<br>interval of minutes,<br>interval of minutes to seconds,<br>or interval of seconds.</p>
<p>一个白天时间间隔由+days hours:months:seconds.fractional从 -999999 23:59:59.999999999到的值组成+999999 23:59:59.999999999.<br>所有类型的分辨率的值表示都是相同的.<br>例如,70 秒的间隔始终以天到秒的间隔格式(使用默认精度)表示:+00 00:01:10.000000.</p>
<p>INTERVAL DAY<br>INTERVAL DAY(p1)<br>INTERVAL DAY(p1) TO HOUR<br>INTERVAL DAY(p1) TO MINUTE<br>INTERVAL DAY(p1) TO SECOND(p2)<br>INTERVAL HOUR<br>INTERVAL HOUR TO MINUTE<br>INTERVAL HOUR TO SECOND(p2)<br>INTERVAL MINUTE<br>INTERVAL MINUTE TO SECOND(p2)<br>INTERVAL SECOND<br>INTERVAL SECOND(p2)</p>
<p>可以使用上述组合声明类型,其中p1是天数(天精度)和p2小数秒数(小数精度).<br>p1必须有一个介于1和6(包括两者)之间的值.<br>p2必须有一个介于0 和9(包括两者)之间的值.<br>如果p1指定 no,则默认等于2.<br>如果p2指定 no,则默认等于6.</p>
<h4 id="Constructured-Data-Types-构造数据类型"><a href="#Constructured-Data-Types-构造数据类型" class="headerlink" title="Constructured Data Types(构造数据类型)"></a>Constructured Data Types(构造数据类型)</h4><h5 id="ARRAY"><a href="#ARRAY" class="headerlink" title="ARRAY"></a>ARRAY</h5><p>具有相同子类型的元素数组的数据类型.<br>与 SQL 标准相比,数组的最大基数不能指定,但固定为2,147,483,647. 此外,支持任何有效类型作为子类型.</p>
<p><code>ARRAY&lt;t&gt;</code><br>t ARRAY</p>
<p>可以使用<code>ARRAY&lt;t&gt;</code>其中t包含的元素的数据类型来声明类型.</p>
<p>t ARRAY是更接近 SQL 标准的同义词.<br>例如,INT ARRAY等价于<code>ARRAY&lt;INT&gt;</code>.</p>
<h5 id="MAP"><a href="#MAP" class="headerlink" title="MAP"></a>MAP</h5><p>NULL将键(包括)映射到值(包括)的关联数组的数据类型NULL.<br>地图不能包含重复的键.<br>每个键最多可以映射到一个值.</p>
<p>没有元素类型的限制.<br>确保唯一性是用户的责任.</p>
<p>map 类型是 SQL 标准的扩展.</p>
<p><code>MAP&lt;kt, vt&gt;</code></p>
<p>可以使用<code>MAP&lt;kt, vt&gt;</code>其中kt键元素vt的数据类型和值元素的数据类型来声明类型.</p>
<h5 id="MULTISET"><a href="#MULTISET" class="headerlink" title="MULTISET"></a>MULTISET</h5><p>多重集 (=bag) 的数据类型.<br>与集合不同的是,它允许每个具有共同子类型的元素有多个实例.<br>每个唯一值(包括NULL)都映射到某个多重性.</p>
<p>没有元素类型的限制.<br>确保唯一性是用户的责任.</p>
<p><code>MULTISET&lt;t&gt;</code><br>t MULTISET</p>
<p>可以使用<code>MULTISET&lt;t&gt;</code>其中t包含的元素的数据类型来声明类型.</p>
<p>t MULTISET是更接近 SQL 标准的同义词.<br>例如,INT MULTISET等价于<code>MULTISET&lt;INT&gt;</code>.</p>
<h5 id="ROW"><a href="#ROW" class="headerlink" title="ROW"></a>ROW</h5><p>字段序列的数据类型.</p>
<p>字段由字段名称/字段类型和可选描述组成.<br>表中最具体的行类型是行类型.<br>在这种情况下,行的每一列对应于与列具有相同序号位置的行类型的字段.</p>
<p>与 SQL 标准相比,可选的字段描述简化了复杂结构的处理.</p>
<p>行类型类似于STRUCT从其他不符合标准的框架中已知的类型.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ROW&lt;n0 t0, n1 t1, ...&gt;</span><br><span class="line">ROW&lt;n0 t0 &#39;d0&#39;, n1 t1 &#39;d1&#39;, ...&gt;</span><br><span class="line"></span><br><span class="line">ROW(n0 t0, n1 t1, ...&gt;</span><br><span class="line">ROW(n0 t0 &#39;d0&#39;, n1 t1 &#39;d1&#39;, ...)</span><br></pre></td></tr></table></figure>

<p>可以使用字段<code>ROW&lt;n0 t0 &#39;d0&#39;, n1 t1 &#39;d1&#39;, ...&gt;</code>的n唯一名称,字段t的逻辑类型,字段d的描述来声明类型.</p>
<p>ROW(...)是更接近 SQL 标准的同义词.<br>例如,ROW(myField INT, myOtherField BOOLEAN)等价于<code>ROW&lt;myField INT, myOtherField BOOLEAN&gt;</code>.</p>
<h4 id="用户定义的数据类型"><a href="#用户定义的数据类型" class="headerlink" title="用户定义的数据类型"></a>用户定义的数据类型</h4><p>注意尚不完全支持用户定义的数据类型.<br>它们目前(从 Flink 1.11 开始)仅在参数和函数返回类型中作为未注册的结构化类型公开.</p>
<p>结构化类型类似于面向对象编程语言中的对象.<br>它包含零个/一个或多个属性.<br>每个属性都由名称和类型组成.</p>
<p>有两种结构化类型:</p>
<ol>
<li>存储在目录中并由目录标识符(如cat.db.MyType)标识的类型.<br>这些等同于结构化类型的 SQL 标准定义.</li>
<li>由实现类(如)标识的匿名定义的/未注册的类型(通常以反射方式提取com.myorg.model.MyType).<br>这些在以编程方式定义表程序时很有用.<br>它们可以重用现有的 JVM 类,而无需再次手动定义数据类型的模式.</li>
</ol>
<h5 id="注册的结构化类型"><a href="#注册的结构化类型" class="headerlink" title="注册的结构化类型"></a>注册的结构化类型</h5><p>目前,不支持注册的结构化类型.<br>因此,它们不能存储在目录中或在CREATE TABLE DDL 中引用.</p>
<h5 id="未注册的结构化类型"><a href="#未注册的结构化类型" class="headerlink" title="未注册的结构化类型"></a>未注册的结构化类型</h5><p>可以使用自动反射提取从常规 POJO(普通旧 Java 对象)创建未注册的结构化类型.<br>结构化类型的实现类必须满足以下要求:</p>
<ol>
<li>该类必须是全局可访问的,这意味着它必须声明为public,static和 not abstract.</li>
<li>该类必须提供带有零参数的默认构造函数或分配所有字段的完整构造函数.</li>
<li>类的所有字段都必须可以通过public声明或遵循通用编码样式的 getter 读取,例如getField(), isField(), field().</li>
<li>类的所有字段都必须可以通过public声明/完全赋值构造函数或遵循常见编码样式(如setField(...)/ )的 setter 写入field(...).</li>
<li>所有字段必须通过反射提取或显式使用@DataTypeHint 注释隐式映射到数据类型.</li>
<li>已声明static或被transient忽略的字段.</li>
</ol>
<p>只要字段类型不(传递地)引用自身,反射提取就支持字段的任意嵌套.</p>
<p>声明的字段类(例如public int age;)必须包含在为本文档中的每种数据类型(例如java.lang.Integer或intfor INT)定义的支持的 JVM 桥接类列表中.</p>
<p>对于某些类,需要注释以便将类映射到数据类型(例如@DataTypeHint(&quot;DECIMAL(10, 2)&quot;) ,为 分配固定的精度和比例java.math.BigDecimal).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// extract fields automatically</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enrich the extraction with precision information</span></span><br><span class="line">  <span class="keyword">public</span> <span class="meta">@DataTypeHint(&quot;DECIMAL(10, 2)&quot;)</span> BigDecimal totalBalance;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enrich the extraction with forcing using RAW types</span></span><br><span class="line">  <span class="keyword">public</span> <span class="meta">@DataTypeHint(&quot;RAW&quot;)</span> Class&lt;?&gt; modelClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DataTypes.of(User.class);</span><br></pre></td></tr></table></figure>

<h4 id="其他数据类型"><a href="#其他数据类型" class="headerlink" title="其他数据类型"></a>其他数据类型</h4><h5 id="BOOLEAN"><a href="#BOOLEAN" class="headerlink" title="BOOLEAN"></a>BOOLEAN</h5><p>布尔值的数据类型,具有(可能)三值逻辑TRUE/FALSE和UNKNOWN.</p>
<p>BOOLEAN</p>
<h5 id="RAW"><a href="#RAW" class="headerlink" title="RAW"></a>RAW</h5><p>任意序列化类型的数据类型.<br>这种类型是表生态系统中的黑盒,仅在边缘反序列化.<br>原始类型是 SQL 标准的扩展.</p>
<p>RAW(&#39;class&#39;, &#39;snapshot&#39;)</p>
<p>可以使用RAW(&#39;class&#39;, &#39;snapshot&#39;)whereclass是原始类来声明该类型,并 以 Base64 编码snapshot进行序列化.<br>TypeSerializerSnapshot通常,类型字符串不是直接声明的,而是在持久化类型时生成的.</p>
<p>在 API 中,RAW可以通过直接提供Class+TypeSerializer或通过传递Class并让框架从那里提取Class+来声明类型.<br>TypeSerializer</p>
<h5 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h5><p>用于表示无类型NULL值的数据类型.</p>
<p>null 类型是对 SQL 标准的扩展.<br>空类型除了 之外没有其他值NULL,因此,它可以转换为类似于 JVM 语义的任何可空类型.<br>此类型有助于在使用文字的 API 调用中表示未知类型,NULL并桥接到定义此类类型的格式(如 JSON 或 Avro).<br>这种类型在实践中不是很有用,这里只是为了完整性而提到.</p>
<p>NULL</p>
<h3 id="CAST-方法"><a href="#CAST-方法" class="headerlink" title="CAST 方法"></a>CAST 方法</h3><p>Flink Table API 和 Flink SQL 支持从 输入 数据类型 到 目标 数据类型的转换.<br>有的转换 无论输入值是什么都能保证转换成功,而有些转换则会在运行时失败(即不可能转换为 目标 数据类型对应的值).<br>例如,将 INT 数据类型的值转换为 STRING 数据类型一定能转换成功,但无法保证将 STRING 数据类型转换为 INT 数据类型.</p>
<p>在生成执行计划时,Flink 的 SQL 检查器会拒绝提交那些不可能直接转换为 目标 数据类型的SQL,并抛出 ValidationException 异常, 例如从 TIMESTAMP 类型转化到 INTERVAL 类型.<br>然而有些查询即使通过了 SQL 检查器的验证,依旧可能会在运行期间转换失败,这就需要用户正确处理这些失败了.</p>
<p>在 Flink Table API 和 Flink SQL 中,可以用下面两个内置方法来进行转换操作:</p>
<ol>
<li><p>CAST:定义在 SQL 标准的 CAST 方法.<br>在某些容易发生转换失败的查询场景中,当实际输入数据不合法时,作业便会运行失败.<br>类型推导会保留输入类型的可空性.</p>
</li>
<li><p>TRY_CAST:常规 CAST 方法的扩展,当转换失败时返回 NULL.<br>该方法的返回值允许为空.</p>
</li>
</ol>
<p>例如:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CAST</span>(<span class="string">&#x27;42&#x27;</span> <span class="keyword">AS</span> <span class="type">INT</span>) <span class="comment">--- 结果返回数字 42 的 INT 格式(非空)</span></span><br><span class="line"><span class="built_in">CAST</span>(<span class="keyword">NULL</span> <span class="keyword">AS</span> <span class="type">VARCHAR</span>) <span class="comment">--- 结果返回 VARCHAR 类型的空值</span></span><br><span class="line"><span class="built_in">CAST</span>(<span class="string">&#x27;non-number&#x27;</span> <span class="keyword">AS</span> <span class="type">INT</span>) <span class="comment">--- 抛出异常,并停止作业</span></span><br><span class="line"></span><br><span class="line">TRY_CAST(<span class="string">&#x27;42&#x27;</span> <span class="keyword">AS</span> <span class="type">INT</span>) <span class="comment">--- 结果返回数字 42 的 INT 格式</span></span><br><span class="line">TRY_CAST(<span class="keyword">NULL</span> <span class="keyword">AS</span> <span class="type">VARCHAR</span>) <span class="comment">--- 结果返回 VARCHAR 类型的空值</span></span><br><span class="line">TRY_CAST(<span class="string">&#x27;non-number&#x27;</span> <span class="keyword">AS</span> <span class="type">INT</span>) <span class="comment">--- 结果返回 INT 类型的空值</span></span><br><span class="line"><span class="built_in">COALESCE</span>(TRY_CAST(<span class="string">&#x27;non-number&#x27;</span> <span class="keyword">AS</span> <span class="type">INT</span>), <span class="number">0</span>) <span class="comment">--- 结果返回数字 0 的 INT 格式(非空)</span></span><br></pre></td></tr></table></figure>

<h4 id="旧版本-CAST-方法"><a href="#旧版本-CAST-方法" class="headerlink" title="旧版本 CAST 方法"></a>旧版本 CAST 方法</h4><p>用户可以通过将参数 table.exec.legacy-cast-behaviour 设置为 enabled 来启用 1.15 版本之前的 CAST 行为.<br>在 Flink 1.15 版本此参数默认为 disabled.</p>
<p>如果设置为 enabled,请注意以下问题:<br>转换为 CHAR/VARCHAR/BINARY/VARBINARY 数据类型时,不再自动修剪(trim)或填充(pad).<br>使用 CAST 时不再会因为转化失败而停止作业,只会返回 NULL,但不会像 TRY_CAST 那样推断正确的类型.<br>CHAR/VARCHAR/STRING 的转换结果会有一些细微的差别.</p>
<p>我们 不建议 配置此参数,而是 强烈建议 在新项目中保持这个参数为默认禁用,以使用最新版本的 CAST 方法.<br>在下一个版本,这个参数会被移除.</p>
<h3 id="数据类型提取"><a href="#数据类型提取" class="headerlink" title="数据类型提取"></a>数据类型提取</h3><p>在 API 的许多位置,Flink 尝试使用反射从类信息中自动提取数据类型,以避免重复的手动模式工作.<br>但是,反射性地提取数据类型并不总是成功的,因为可能会丢失逻辑信息.<br>因此,可能需要在类或字段声明附近添加其他信息以支持提取逻辑.</p>
<h2 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h2><p>Flink 为日期和时间提供了丰富的数据类型, 包括 DATE, TIME, TIMESTAMP, TIMESTAMP_LTZ, INTERVAL YEAR TO MONTH, INTERVAL DAY TO SECOND (更多详情请参考 Date and Time).<br>Flink 支持在 session (会话)级别设置时区(更多详情请参考 table.local-time-zone).<br>Flink 对多种时间类型和时区的支持使得跨时区的数据处理变得非常容易.</p>
<h3 id="TIMESTAMP-vs-TIMESTAMP-LTZ"><a href="#TIMESTAMP-vs-TIMESTAMP-LTZ" class="headerlink" title="TIMESTAMP vs TIMESTAMP_LTZ"></a>TIMESTAMP vs TIMESTAMP_LTZ</h3><h4 id="TIMESTAMP-类型"><a href="#TIMESTAMP-类型" class="headerlink" title="TIMESTAMP 类型"></a>TIMESTAMP 类型</h4><p>TIMESTAMP(p) 是 TIMESTAMP(p) WITHOUT TIME ZONE 的简写, 精度 p 支持的范围是0-9, 默认是6.<br>TIMESTAMP 用于描述年, 月, 日, 小时, 分钟, 秒 和 小数秒对应的时间戳.<br>TIMESTAMP 可以通过一个字符串来指定,例如:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="type">TIMESTAMP</span> <span class="string">&#x27;1970-01-01 00:00:04.001&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1970</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">04.001</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+</span></span><br></pre></td></tr></table></figure>

<h4 id="TIMESTAMP-LTZ-类型"><a href="#TIMESTAMP-LTZ-类型" class="headerlink" title="TIMESTAMP_LTZ 类型"></a>TIMESTAMP_LTZ 类型</h4><p>TIMESTAMP_LTZ(p) 是 TIMESTAMP(p) WITH LOCAL TIME ZONE 的简写, 精度 p 支持的范围是0-9, 默认是6.</p>
<p>TIMESTAMP_LTZ 用于描述时间线上的绝对时间点, 使用 long 保存从 epoch 至今的毫秒数, 使用int保存毫秒中的纳秒数.<br>epoch 时间是从 java 的标准 epoch 时间 1970-01-01T00:00:00Z 开始计算.<br>在计算和可视化时, 每个 TIMESTAMP_LTZ 类型的数据都是使用的 session (会话)中配置的时区.</p>
<p>TIMESTAMP_LTZ 没有字符串表达形式因此无法通过字符串来指定, 可以通过一个 long 类型的 epoch 时间来转化(例如: 通过 Java 来产生一个 long 类型的 epoch 时间 System.currentTimeMillis())</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> T1 <span class="keyword">AS</span> <span class="keyword">SELECT</span> TO_TIMESTAMP_LTZ(<span class="number">4001</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">SET</span> <span class="string">&#x27;table.local-time-zone&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;UTC&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> T1;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span> TO_TIMESTAMP_LTZ(<span class="number">4001</span>, <span class="number">3</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">1970</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">04.001</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="string">&#x27;table.local-time-zone&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> T1;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span> TO_TIMESTAMP_LTZ(<span class="number">4001</span>, <span class="number">3</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">1970</span><span class="number">-01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">04.001</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br></pre></td></tr></table></figure>

<p>TIMESTAMP_LTZ 可以用于跨时区的计算,因为它是一个基于 epoch 的绝对时间点(比如上例中的 4001 毫秒)代表的就是不同时区的同一个绝对时间点.</p>
<h3 id="时区的作用"><a href="#时区的作用" class="headerlink" title="时区的作用"></a>时区的作用</h3><p>本地时区定义了当前 session(会话)所在的时区, 你可以在 Sql client 或者应用程序中配置.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置为 UTC 时区</span></span><br><span class="line"><span class="keyword">SET</span> <span class="string">&#x27;table.local-time-zone&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;UTC&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置为上海时区</span></span><br><span class="line"><span class="keyword">SET</span> <span class="string">&#x27;table.local-time-zone&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置为Los_Angeles时区</span></span><br><span class="line"><span class="keyword">SET</span> <span class="string">&#x27;table.local-time-zone&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;America/Los_Angeles&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EnvironmentSettings envSetting = EnvironmentSettings.inStreamingMode();</span><br><span class="line">TableEnvironment tEnv = TableEnvironment.create(envSetting);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置为 UTC 时区</span></span><br><span class="line">tEnv.getConfig().setLocalTimeZone(ZoneId.of(<span class="string">&quot;UTC&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置为上海时区</span></span><br><span class="line">tEnv.getConfig().setLocalTimeZone(ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置为 Los_Angeles 时区</span></span><br><span class="line">tEnv.getConfig().setLocalTimeZone(ZoneId.of(<span class="string">&quot;America/Los_Angeles&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>session(会话)的时区设置在 Flink SQL 中非常有用, 它的主要用法如下.</p>
<h4 id="确定时间函数的返回值"><a href="#确定时间函数的返回值" class="headerlink" title="确定时间函数的返回值"></a>确定时间函数的返回值</h4><p>session (会话)中配置的时区会对以下函数生效.</p>
<p>LOCALTIME<br>LOCALTIMESTAMP<br>CURRENT_DATE<br>CURRENT_TIME<br>CURRENT_TIMESTAMP<br>CURRENT_ROW_TIMESTAMP()<br>NOW()<br>PROCTIME()</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="string">&#x27;sql-client.execution.result-mode&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;tableau&#x27;</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> MyView1 <span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="built_in">LOCALTIME</span>, <span class="built_in">LOCALTIMESTAMP</span>, <span class="built_in">CURRENT_DATE</span>, <span class="built_in">CURRENT_TIME</span>, <span class="built_in">CURRENT_TIMESTAMP</span>, CURRENT_ROW_TIMESTAMP(), NOW(), PROCTIME();</span><br><span class="line"><span class="keyword">DESC</span> MyView1;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+-----------------------------+-------+-----+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span>                   name <span class="operator">|</span>                        type <span class="operator">|</span>  <span class="keyword">null</span> <span class="operator">|</span> key <span class="operator">|</span> extras <span class="operator">|</span> watermark <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+-----------------------------+-------+-----+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span>              <span class="built_in">LOCALTIME</span> <span class="operator">|</span>                     <span class="type">TIME</span>(<span class="number">0</span>) <span class="operator">|</span> <span class="literal">false</span> <span class="operator">|</span>     <span class="operator">|</span>        <span class="operator">|</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>         <span class="built_in">LOCALTIMESTAMP</span> <span class="operator">|</span>                <span class="type">TIMESTAMP</span>(<span class="number">3</span>) <span class="operator">|</span> <span class="literal">false</span> <span class="operator">|</span>     <span class="operator">|</span>        <span class="operator">|</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>           <span class="built_in">CURRENT_DATE</span> <span class="operator">|</span>                        <span class="type">DATE</span> <span class="operator">|</span> <span class="literal">false</span> <span class="operator">|</span>     <span class="operator">|</span>        <span class="operator">|</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>           <span class="built_in">CURRENT_TIME</span> <span class="operator">|</span>                     <span class="type">TIME</span>(<span class="number">0</span>) <span class="operator">|</span> <span class="literal">false</span> <span class="operator">|</span>     <span class="operator">|</span>        <span class="operator">|</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>      <span class="built_in">CURRENT_TIMESTAMP</span> <span class="operator">|</span>            TIMESTAMP_LTZ(<span class="number">3</span>) <span class="operator">|</span> <span class="literal">false</span> <span class="operator">|</span>     <span class="operator">|</span>        <span class="operator">|</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>CURRENT_ROW_TIMESTAMP() <span class="operator">|</span>            TIMESTAMP_LTZ(<span class="number">3</span>) <span class="operator">|</span> <span class="literal">false</span> <span class="operator">|</span>     <span class="operator">|</span>        <span class="operator">|</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>                  NOW() <span class="operator">|</span>            TIMESTAMP_LTZ(<span class="number">3</span>) <span class="operator">|</span> <span class="literal">false</span> <span class="operator">|</span>     <span class="operator">|</span>        <span class="operator">|</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>             PROCTIME() <span class="operator">|</span> TIMESTAMP_LTZ(<span class="number">3</span>) <span class="operator">*</span>PROCTIME<span class="operator">*</span> <span class="operator">|</span> <span class="literal">false</span> <span class="operator">|</span>     <span class="operator">|</span>        <span class="operator">|</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+-----------------------------+-------+-----+--------+-----------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="string">&#x27;table.local-time-zone&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;UTC&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> MyView1;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------------------------+--------------+--------------+-------------------------+-------------------------+-------------------------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">LOCALTIME</span> <span class="operator">|</span>          <span class="built_in">LOCALTIMESTAMP</span> <span class="operator">|</span> <span class="built_in">CURRENT_DATE</span> <span class="operator">|</span> <span class="built_in">CURRENT_TIME</span> <span class="operator">|</span>       <span class="built_in">CURRENT_TIMESTAMP</span> <span class="operator">|</span> CURRENT_ROW_TIMESTAMP() <span class="operator">|</span>                   NOW() <span class="operator">|</span>              PROCTIME() <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------------------------+--------------+--------------+-------------------------+-------------------------+-------------------------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">15</span>:<span class="number">18</span>:<span class="number">36</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">36.384</span> <span class="operator">|</span>   <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="operator">|</span>     <span class="number">15</span>:<span class="number">18</span>:<span class="number">36</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">36.384</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">36.384</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">36.384</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">36.384</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------------------------+--------------+--------------+-------------------------+-------------------------+-------------------------+-------------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="string">&#x27;table.local-time-zone&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> MyView1;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------------------------+--------------+--------------+-------------------------+-------------------------+-------------------------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">LOCALTIME</span> <span class="operator">|</span>          <span class="built_in">LOCALTIMESTAMP</span> <span class="operator">|</span> <span class="built_in">CURRENT_DATE</span> <span class="operator">|</span> <span class="built_in">CURRENT_TIME</span> <span class="operator">|</span>       <span class="built_in">CURRENT_TIMESTAMP</span> <span class="operator">|</span> CURRENT_ROW_TIMESTAMP() <span class="operator">|</span>                   NOW() <span class="operator">|</span>              PROCTIME() <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------------------------+--------------+--------------+-------------------------+-------------------------+-------------------------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">23</span>:<span class="number">18</span>:<span class="number">36</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">23</span>:<span class="number">18</span>:<span class="number">36.384</span> <span class="operator">|</span>   <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="operator">|</span>     <span class="number">23</span>:<span class="number">18</span>:<span class="number">36</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">23</span>:<span class="number">18</span>:<span class="number">36.384</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">23</span>:<span class="number">18</span>:<span class="number">36.384</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">23</span>:<span class="number">18</span>:<span class="number">36.384</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">23</span>:<span class="number">18</span>:<span class="number">36.384</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------------------------+--------------+--------------+-------------------------+-------------------------+-------------------------+-------------------------+</span></span><br></pre></td></tr></table></figure>

<h4 id="TIMESTAMP-LTZ-字符串表示"><a href="#TIMESTAMP-LTZ-字符串表示" class="headerlink" title="TIMESTAMP_LTZ 字符串表示"></a>TIMESTAMP_LTZ 字符串表示</h4><p>当一个 TIMESTAMP_LTZ 值转为 string 格式时, session 中配置的时区会生效.<br>例如打印这个值,将类型强制转化为 STRING 类型, 将类型强制转换为 TIMESTAMP ,将 TIMESTAMP 的值转化为 TIMESTAMP_LTZ 类型:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> MyView2 <span class="keyword">AS</span> <span class="keyword">SELECT</span> TO_TIMESTAMP_LTZ(<span class="number">4001</span>, <span class="number">3</span>) <span class="keyword">AS</span> ltz, <span class="type">TIMESTAMP</span> <span class="string">&#x27;1970-01-01 00:00:01.001&#x27;</span>  <span class="keyword">AS</span> ntz;</span><br><span class="line"><span class="keyword">DESC</span> MyView2;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------------------+-------+-----+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span> name <span class="operator">|</span>             type <span class="operator">|</span>  <span class="keyword">null</span> <span class="operator">|</span> key <span class="operator">|</span> extras <span class="operator">|</span> watermark <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------------------+-------+-----+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span>  ltz <span class="operator">|</span> TIMESTAMP_LTZ(<span class="number">3</span>) <span class="operator">|</span>  <span class="literal">true</span> <span class="operator">|</span>     <span class="operator">|</span>        <span class="operator">|</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  ntz <span class="operator">|</span>     <span class="type">TIMESTAMP</span>(<span class="number">3</span>) <span class="operator">|</span> <span class="literal">false</span> <span class="operator">|</span>     <span class="operator">|</span>        <span class="operator">|</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------------------+-------+-----+--------+-----------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="string">&#x27;table.local-time-zone&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;UTC&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> MyView2;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span>                     ltz <span class="operator">|</span>                     ntz <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1970</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">04.001</span> <span class="operator">|</span> <span class="number">1970</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">01.001</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="string">&#x27;table.local-time-zone&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> MyView2;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span>                     ltz <span class="operator">|</span>                     ntz <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1970</span><span class="number">-01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">04.001</span> <span class="operator">|</span> <span class="number">1970</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">01.001</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> MyView3 <span class="keyword">AS</span> <span class="keyword">SELECT</span> ltz, <span class="built_in">CAST</span>(ltz <span class="keyword">AS</span> <span class="type">TIMESTAMP</span>(<span class="number">3</span>)), <span class="built_in">CAST</span>(ltz <span class="keyword">AS</span> STRING), ntz, <span class="built_in">CAST</span>(ntz <span class="keyword">AS</span> TIMESTAMP_LTZ(<span class="number">3</span>)) <span class="keyword">FROM</span> MyView2;</span><br><span class="line"><span class="keyword">DESC</span> MyView3;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+------------------+-------+-----+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span>                          name <span class="operator">|</span>             type <span class="operator">|</span>  <span class="keyword">null</span> <span class="operator">|</span> key <span class="operator">|</span> extras <span class="operator">|</span> watermark <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+------------------+-------+-----+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span>                           ltz <span class="operator">|</span> TIMESTAMP_LTZ(<span class="number">3</span>) <span class="operator">|</span>  <span class="literal">true</span> <span class="operator">|</span>     <span class="operator">|</span>        <span class="operator">|</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>     <span class="built_in">CAST</span>(ltz <span class="keyword">AS</span> <span class="type">TIMESTAMP</span>(<span class="number">3</span>)) <span class="operator">|</span>     <span class="type">TIMESTAMP</span>(<span class="number">3</span>) <span class="operator">|</span>  <span class="literal">true</span> <span class="operator">|</span>     <span class="operator">|</span>        <span class="operator">|</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>           <span class="built_in">CAST</span>(ltz <span class="keyword">AS</span> STRING) <span class="operator">|</span>           STRING <span class="operator">|</span>  <span class="literal">true</span> <span class="operator">|</span>     <span class="operator">|</span>        <span class="operator">|</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>                           ntz <span class="operator">|</span>     <span class="type">TIMESTAMP</span>(<span class="number">3</span>) <span class="operator">|</span> <span class="literal">false</span> <span class="operator">|</span>     <span class="operator">|</span>        <span class="operator">|</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">CAST</span>(ntz <span class="keyword">AS</span> TIMESTAMP_LTZ(<span class="number">3</span>)) <span class="operator">|</span> TIMESTAMP_LTZ(<span class="number">3</span>) <span class="operator">|</span> <span class="literal">false</span> <span class="operator">|</span>     <span class="operator">|</span>        <span class="operator">|</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+------------------+-------+-----+--------+-----------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> MyView3;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+---------------------------+-------------------------+-------------------------+-------------------------------+</span></span><br><span class="line"><span class="operator">|</span>                     ltz <span class="operator">|</span> <span class="built_in">CAST</span>(ltz <span class="keyword">AS</span> <span class="type">TIMESTAMP</span>(<span class="number">3</span>)) <span class="operator">|</span>     <span class="built_in">CAST</span>(ltz <span class="keyword">AS</span> STRING) <span class="operator">|</span>                     ntz <span class="operator">|</span> <span class="built_in">CAST</span>(ntz <span class="keyword">AS</span> TIMESTAMP_LTZ(<span class="number">3</span>)) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+---------------------------+-------------------------+-------------------------+-------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1970</span><span class="number">-01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">04.001</span> <span class="operator">|</span>   <span class="number">1970</span><span class="number">-01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">04.001</span> <span class="operator">|</span> <span class="number">1970</span><span class="number">-01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">04.001</span> <span class="operator">|</span> <span class="number">1970</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">01.001</span> <span class="operator">|</span>       <span class="number">1970</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">01.001</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+---------------------------+-------------------------+-------------------------+-------------------------------+</span></span><br></pre></td></tr></table></figure>

<h3 id="时间属性和时区"><a href="#时间属性和时区" class="headerlink" title="时间属性和时区"></a>时间属性和时区</h3><p>更多时间属性相关的详细介绍, 请参考 Time Attribute .</p>
<h4 id="处理时间和时区"><a href="#处理时间和时区" class="headerlink" title="处理时间和时区"></a>处理时间和时区</h4><p>Flink SQL 使用函数 PROCTIME() 来定义处理时间属性, 该函数返回的类型是 TIMESTAMP_LTZ .</p>
<p>在 Flink1.13 之前, PROCTIME() 函数返回的类型是 TIMESTAMP , 返回值是UTC时区下的 TIMESTAMP .<br>例如: 当上海的时间为 2021-03-01 12:00:00 时, PROCTIME() 显示的时间却是错误的 2021-03-01 04:00:00 .<br>这个问题在 Flink 1.13 中修复了, 因此用户不用再去处理时区的问题了.</p>
<p>PROCTIME() 返回的是本地时区的时间, 使用 TIMESTAMP_LTZ 类型也可以支持夏令时时间.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="string">&#x27;table.local-time-zone&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;UTC&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> PROCTIME();</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+</span></span><br><span class="line"><span class="operator">|</span>              PROCTIME() <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">31.387</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="string">&#x27;table.local-time-zone&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> PROCTIME();</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+</span></span><br><span class="line"><span class="operator">|</span>              PROCTIME() <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">22</span>:<span class="number">48</span>:<span class="number">31.387</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> MyTable1 (</span><br><span class="line">  item STRING,</span><br><span class="line">  price <span class="keyword">DOUBLE</span>,</span><br><span class="line">  proctime <span class="keyword">as</span> PROCTIME()</span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">  <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;socket&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;hostname&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;port&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;9999&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;format&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;csv&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> MyView3 <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  TUMBLE_START(proctime, <span class="type">INTERVAL</span> <span class="string">&#x27;10&#x27;</span> MINUTES) <span class="keyword">AS</span> window_start,</span><br><span class="line">  TUMBLE_END(proctime, <span class="type">INTERVAL</span> <span class="string">&#x27;10&#x27;</span> MINUTES) <span class="keyword">AS</span> window_end,</span><br><span class="line">  TUMBLE_PROCTIME(proctime, <span class="type">INTERVAL</span> <span class="string">&#x27;10&#x27;</span> MINUTES) <span class="keyword">as</span> window_proctime,</span><br><span class="line">  item,</span><br><span class="line">  <span class="built_in">MAX</span>(price) <span class="keyword">as</span> max_price</span><br><span class="line"><span class="keyword">FROM</span> MyTable1</span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> TUMBLE(proctime, <span class="type">INTERVAL</span> <span class="string">&#x27;10&#x27;</span> MINUTES), item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DESC</span> MyView3;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------------------------+-------+-----+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span>           name  <span class="operator">|</span>                        type <span class="operator">|</span>  <span class="keyword">null</span> <span class="operator">|</span> key <span class="operator">|</span> extras <span class="operator">|</span> watermark <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------------------------+-------+-----+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span>    window_start <span class="operator">|</span>                <span class="type">TIMESTAMP</span>(<span class="number">3</span>) <span class="operator">|</span> <span class="literal">false</span> <span class="operator">|</span>     <span class="operator">|</span>        <span class="operator">|</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>      window_end <span class="operator">|</span>                <span class="type">TIMESTAMP</span>(<span class="number">3</span>) <span class="operator">|</span> <span class="literal">false</span> <span class="operator">|</span>     <span class="operator">|</span>        <span class="operator">|</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> window_proctime <span class="operator">|</span> TIMESTAMP_LTZ(<span class="number">3</span>) <span class="operator">*</span>PROCTIME<span class="operator">*</span> <span class="operator">|</span> <span class="literal">false</span> <span class="operator">|</span>     <span class="operator">|</span>        <span class="operator">|</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>            item <span class="operator">|</span>                      STRING <span class="operator">|</span> <span class="literal">true</span>  <span class="operator">|</span>     <span class="operator">|</span>        <span class="operator">|</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       max_price <span class="operator">|</span>                      <span class="keyword">DOUBLE</span> <span class="operator">|</span>  <span class="literal">true</span> <span class="operator">|</span>     <span class="operator">|</span>        <span class="operator">|</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------------------------+-------+-----+--------+-----------+</span></span><br></pre></td></tr></table></figure>

<p>在终端执行以下命令写入数据到 MyTable1 :</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nc -lk 9999</span><br><span class="line">A,1.1</span><br><span class="line">B,1.2</span><br><span class="line">A,1.8</span><br><span class="line">B,2.5</span><br><span class="line">C,3.8</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="string">&#x27;table.local-time-zone&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;UTC&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> MyView3;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------------------------+-------------------------+------+-----------+</span></span><br><span class="line"><span class="operator">|</span>            window_start <span class="operator">|</span>              window_end <span class="operator">|</span>          window_procime <span class="operator">|</span> item <span class="operator">|</span> max_price <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------------------------+-------------------------+------+-----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">14</span>:<span class="number">00</span>:<span class="number">00.000</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">14</span>:<span class="number">10</span>:<span class="number">00.000</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">14</span>:<span class="number">10</span>:<span class="number">00.005</span> <span class="operator">|</span>    A <span class="operator">|</span>       <span class="number">1.8</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">14</span>:<span class="number">00</span>:<span class="number">00.000</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">14</span>:<span class="number">10</span>:<span class="number">00.000</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">14</span>:<span class="number">10</span>:<span class="number">00.007</span> <span class="operator">|</span>    B <span class="operator">|</span>       <span class="number">2.5</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">14</span>:<span class="number">00</span>:<span class="number">00.000</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">14</span>:<span class="number">10</span>:<span class="number">00.000</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">14</span>:<span class="number">10</span>:<span class="number">00.007</span> <span class="operator">|</span>    C <span class="operator">|</span>       <span class="number">3.8</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------------------------+-------------------------+------+-----------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="string">&#x27;table.local-time-zone&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> MyView3;</span><br></pre></td></tr></table></figure>

<p>相比在 UTC 时区下的计算结果, 在 Asia/Shanghai 时区下计算的窗口开始时间, 窗口结束时间和窗口处理时间是不同的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------+-------------------------+-------------------------+------+-----------+</span><br><span class="line">|            window_start |              window_end |          window_procime | item | max_price |</span><br><span class="line">+-------------------------+-------------------------+-------------------------+------+-----------+</span><br><span class="line">| 2021-04-15 22:00:00.000 | 2021-04-15 22:10:00.000 | 2021-04-15 22:10:00.005 |    A |       1.8 |</span><br><span class="line">| 2021-04-15 22:00:00.000 | 2021-04-15 22:10:00.000 | 2021-04-15 22:10:00.007 |    B |       2.5 |</span><br><span class="line">| 2021-04-15 22:00:00.000 | 2021-04-15 22:10:00.000 | 2021-04-15 22:10:00.007 |    C |       3.8 |</span><br><span class="line">+-------------------------+-------------------------+-------------------------+------+-----------+</span><br></pre></td></tr></table></figure>

<p>处理时间窗口是不确定的, 每次运行都会返回不同的窗口和聚合结果.<br>以上的示例只用于说明时区如何影响处理时间窗口.</p>
<h4 id="事件时间和时区"><a href="#事件时间和时区" class="headerlink" title="事件时间和时区"></a>事件时间和时区</h4><p>Flink 支持在 TIMESTAMP 列和 TIMESTAMP_LTZ 列上定义时间属性.</p>
<h5 id="TIMESTAMP-上的事件时间属性"><a href="#TIMESTAMP-上的事件时间属性" class="headerlink" title="TIMESTAMP 上的事件时间属性"></a>TIMESTAMP 上的事件时间属性</h5><p>如果 source 中的时间用于表示年-月-日-小时-分钟-秒, 通常是一个不带时区的字符串, 例如: 2020-04-15 20:13:40.564.<br>推荐在 TIMESTAMP 列上定义事件时间属性.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> MyTable2 (</span><br><span class="line">  item STRING,</span><br><span class="line">  price <span class="keyword">DOUBLE</span>,</span><br><span class="line">  ts <span class="type">TIMESTAMP</span>(<span class="number">3</span>), <span class="comment">-- TIMESTAMP data type</span></span><br><span class="line">  WATERMARK <span class="keyword">FOR</span> ts <span class="keyword">AS</span> ts <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="string">&#x27;10&#x27;</span> <span class="keyword">SECOND</span></span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">  <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;socket&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;hostname&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;port&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;9999&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;format&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;csv&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> MyView4 <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  TUMBLE_START(ts, <span class="type">INTERVAL</span> <span class="string">&#x27;10&#x27;</span> MINUTES) <span class="keyword">AS</span> window_start,</span><br><span class="line">  TUMBLE_END(ts, <span class="type">INTERVAL</span> <span class="string">&#x27;10&#x27;</span> MINUTES) <span class="keyword">AS</span> window_end,</span><br><span class="line">  TUMBLE_ROWTIME(ts, <span class="type">INTERVAL</span> <span class="string">&#x27;10&#x27;</span> MINUTES) <span class="keyword">as</span> window_rowtime,</span><br><span class="line">  item,</span><br><span class="line">  <span class="built_in">MAX</span>(price) <span class="keyword">as</span> max_price</span><br><span class="line"><span class="keyword">FROM</span> MyTable2</span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> TUMBLE(ts, <span class="type">INTERVAL</span> <span class="string">&#x27;10&#x27;</span> MINUTES), item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DESC</span> MyView4;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+------------------------+------+-----+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span>           name <span class="operator">|</span>                   type <span class="operator">|</span> <span class="keyword">null</span> <span class="operator">|</span> key <span class="operator">|</span> extras <span class="operator">|</span> watermark <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+------------------------+------+-----+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span>   window_start <span class="operator">|</span>           <span class="type">TIMESTAMP</span>(<span class="number">3</span>) <span class="operator">|</span> <span class="literal">true</span> <span class="operator">|</span>     <span class="operator">|</span>        <span class="operator">|</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>     window_end <span class="operator">|</span>           <span class="type">TIMESTAMP</span>(<span class="number">3</span>) <span class="operator">|</span> <span class="literal">true</span> <span class="operator">|</span>     <span class="operator">|</span>        <span class="operator">|</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> window_rowtime <span class="operator">|</span> <span class="type">TIMESTAMP</span>(<span class="number">3</span>) <span class="operator">*</span>ROWTIME<span class="operator">*</span> <span class="operator">|</span> <span class="literal">true</span> <span class="operator">|</span>     <span class="operator">|</span>        <span class="operator">|</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>           item <span class="operator">|</span>                 STRING <span class="operator">|</span> <span class="literal">true</span> <span class="operator">|</span>     <span class="operator">|</span>        <span class="operator">|</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>      max_price <span class="operator">|</span>                 <span class="keyword">DOUBLE</span> <span class="operator">|</span> <span class="literal">true</span> <span class="operator">|</span>     <span class="operator">|</span>        <span class="operator">|</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+------------------------+------+-----+--------+-----------+</span></span><br></pre></td></tr></table></figure>

<p>在终端执行以下命令用于写入数据到 MyTable2 :</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nc -lk 9999</span><br><span class="line">A,1.1,2021-04-15 14:01:00</span><br><span class="line">B,1.2,2021-04-15 14:02:00</span><br><span class="line">A,1.8,2021-04-15 14:03:00 </span><br><span class="line">B,2.5,2021-04-15 14:04:00</span><br><span class="line">C,3.8,2021-04-15 14:05:00       </span><br><span class="line">C,3.8,2021-04-15 14:11:00</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="string">&#x27;table.local-time-zone&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;UTC&#x27;</span>; </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> MyView4;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------------------------+-------------------------+------+-----------+</span></span><br><span class="line"><span class="operator">|</span>            window_start <span class="operator">|</span>              window_end <span class="operator">|</span>          window_rowtime <span class="operator">|</span> item <span class="operator">|</span> max_price <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------------------------+-------------------------+------+-----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">14</span>:<span class="number">00</span>:<span class="number">00.000</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">14</span>:<span class="number">10</span>:<span class="number">00.000</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">14</span>:<span class="number">09</span>:<span class="number">59.999</span> <span class="operator">|</span>    A <span class="operator">|</span>       <span class="number">1.8</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">14</span>:<span class="number">00</span>:<span class="number">00.000</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">14</span>:<span class="number">10</span>:<span class="number">00.000</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">14</span>:<span class="number">09</span>:<span class="number">59.999</span> <span class="operator">|</span>    B <span class="operator">|</span>       <span class="number">2.5</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">14</span>:<span class="number">00</span>:<span class="number">00.000</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">14</span>:<span class="number">10</span>:<span class="number">00.000</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">14</span>:<span class="number">09</span>:<span class="number">59.999</span> <span class="operator">|</span>    C <span class="operator">|</span>       <span class="number">3.8</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------------------------+-------------------------+------+-----------+</span></span><br><span class="line"><span class="keyword">SET</span> <span class="string">&#x27;table.local-time-zone&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span>; </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> MyView4;</span><br></pre></td></tr></table></figure>

<p>相比在 UTC 时区下的计算结果, 在 Asia/Shanghai 时区下计算的窗口开始时间, 窗口结束时间和窗口的 rowtime 是相同的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------+-------------------------+-------------------------+------+-----------+</span><br><span class="line">|            window_start |              window_end |          window_rowtime | item | max_price |</span><br><span class="line">+-------------------------+-------------------------+-------------------------+------+-----------+</span><br><span class="line">| 2021-04-15 14:00:00.000 | 2021-04-15 14:10:00.000 | 2021-04-15 14:09:59.999 |    A |       1.8 |</span><br><span class="line">| 2021-04-15 14:00:00.000 | 2021-04-15 14:10:00.000 | 2021-04-15 14:09:59.999 |    B |       2.5 |</span><br><span class="line">| 2021-04-15 14:00:00.000 | 2021-04-15 14:10:00.000 | 2021-04-15 14:09:59.999 |    C |       3.8 |</span><br><span class="line">+-------------------------+-------------------------+-------------------------+------+-----------+</span><br></pre></td></tr></table></figure>

<h5 id="TIMESTAMP-LTZ-上的事件时间属性"><a href="#TIMESTAMP-LTZ-上的事件时间属性" class="headerlink" title="TIMESTAMP_LTZ 上的事件时间属性"></a>TIMESTAMP_LTZ 上的事件时间属性</h5><p>如果源数据中的时间为一个 epoch 时间, 通常是一个 long 值, 例如: 1618989564564 ,推荐将事件时间属性定义在 TIMESTAMP_LTZ 列上.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> MyTable3 (</span><br><span class="line">  item STRING,</span><br><span class="line">  price <span class="keyword">DOUBLE</span>,</span><br><span class="line">  ts <span class="type">BIGINT</span>, <span class="comment">-- long time value in epoch milliseconds</span></span><br><span class="line">  ts_ltz <span class="keyword">AS</span> TO_TIMESTAMP_LTZ(ts, <span class="number">3</span>),</span><br><span class="line">  WATERMARK <span class="keyword">FOR</span> ts_ltz <span class="keyword">AS</span> ts_ltz <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="string">&#x27;10&#x27;</span> <span class="keyword">SECOND</span></span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">  <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;socket&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;hostname&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;port&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;9999&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;format&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;csv&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> MyView5 <span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  TUMBLE_START(ts_ltz, <span class="type">INTERVAL</span> <span class="string">&#x27;10&#x27;</span> MINUTES) <span class="keyword">AS</span> window_start,        </span><br><span class="line">  TUMBLE_END(ts_ltz, <span class="type">INTERVAL</span> <span class="string">&#x27;10&#x27;</span> MINUTES) <span class="keyword">AS</span> window_end,</span><br><span class="line">  TUMBLE_ROWTIME(ts_ltz, <span class="type">INTERVAL</span> <span class="string">&#x27;10&#x27;</span> MINUTES) <span class="keyword">as</span> window_rowtime,</span><br><span class="line">  item,</span><br><span class="line">  <span class="built_in">MAX</span>(price) <span class="keyword">as</span> max_price</span><br><span class="line"><span class="keyword">FROM</span> MyTable3</span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> TUMBLE(ts_ltz, <span class="type">INTERVAL</span> <span class="string">&#x27;10&#x27;</span> MINUTES), item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DESC</span> MyView5;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+----------------------------+-------+-----+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span>           name <span class="operator">|</span>                       type <span class="operator">|</span>  <span class="keyword">null</span> <span class="operator">|</span> key <span class="operator">|</span> extras <span class="operator">|</span> watermark <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+----------------------------+-------+-----+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span>   window_start <span class="operator">|</span>               <span class="type">TIMESTAMP</span>(<span class="number">3</span>) <span class="operator">|</span> <span class="literal">false</span> <span class="operator">|</span>     <span class="operator">|</span>        <span class="operator">|</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>     window_end <span class="operator">|</span>               <span class="type">TIMESTAMP</span>(<span class="number">3</span>) <span class="operator">|</span> <span class="literal">false</span> <span class="operator">|</span>     <span class="operator">|</span>        <span class="operator">|</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> window_rowtime <span class="operator">|</span> TIMESTAMP_LTZ(<span class="number">3</span>) <span class="operator">*</span>ROWTIME<span class="operator">*</span> <span class="operator">|</span>  <span class="literal">true</span> <span class="operator">|</span>     <span class="operator">|</span>        <span class="operator">|</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>           item <span class="operator">|</span>                     STRING <span class="operator">|</span>  <span class="literal">true</span> <span class="operator">|</span>     <span class="operator">|</span>        <span class="operator">|</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>      max_price <span class="operator">|</span>                     <span class="keyword">DOUBLE</span> <span class="operator">|</span>  <span class="literal">true</span> <span class="operator">|</span>     <span class="operator">|</span>        <span class="operator">|</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+----------------------------+-------+-----+--------+-----------+</span></span><br></pre></td></tr></table></figure>

<p>MyTable3 的输入数据为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A,1.1,1618495260000  # The corresponding utc timestamp is 2021-04-15 14:01:00</span><br><span class="line">B,1.2,1618495320000  # The corresponding utc timestamp is 2021-04-15 14:02:00</span><br><span class="line">A,1.8,1618495380000  # The corresponding utc timestamp is 2021-04-15 14:03:00</span><br><span class="line">B,2.5,1618495440000  # The corresponding utc timestamp is 2021-04-15 14:04:00</span><br><span class="line">C,3.8,1618495500000  # The corresponding utc timestamp is 2021-04-15 14:05:00       </span><br><span class="line">C,3.8,1618495860000  # The corresponding utc timestamp is 2021-04-15 14:11:00</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="string">&#x27;table.local-time-zone&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;UTC&#x27;</span>; </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> MyView5;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------------------------+-------------------------+------+-----------+</span></span><br><span class="line"><span class="operator">|</span>            window_start <span class="operator">|</span>              window_end <span class="operator">|</span>          window_rowtime <span class="operator">|</span> item <span class="operator">|</span> max_price <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------------------------+-------------------------+------+-----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">14</span>:<span class="number">00</span>:<span class="number">00.000</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">14</span>:<span class="number">10</span>:<span class="number">00.000</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">14</span>:<span class="number">09</span>:<span class="number">59.999</span> <span class="operator">|</span>    A <span class="operator">|</span>       <span class="number">1.8</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">14</span>:<span class="number">00</span>:<span class="number">00.000</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">14</span>:<span class="number">10</span>:<span class="number">00.000</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">14</span>:<span class="number">09</span>:<span class="number">59.999</span> <span class="operator">|</span>    B <span class="operator">|</span>       <span class="number">2.5</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">14</span>:<span class="number">00</span>:<span class="number">00.000</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">14</span>:<span class="number">10</span>:<span class="number">00.000</span> <span class="operator">|</span> <span class="number">2021</span><span class="number">-04</span><span class="number">-15</span> <span class="number">14</span>:<span class="number">09</span>:<span class="number">59.999</span> <span class="operator">|</span>    C <span class="operator">|</span>       <span class="number">3.8</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------------------------+-------------------------+------+-----------+</span></span><br><span class="line"><span class="keyword">SET</span> <span class="string">&#x27;table.local-time-zone&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span>; </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> MyView5;</span><br></pre></td></tr></table></figure>

<p>相比在 UTC 时区下的计算结果, 在 Asia/Shanghai 时区下计算的窗口开始时间, 窗口结束时间和窗口的 rowtime 是不同的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------+-------------------------+-------------------------+------+-----------+</span><br><span class="line">|            window_start |              window_end |          window_rowtime | item | max_price |</span><br><span class="line">+-------------------------+-------------------------+-------------------------+------+-----------+</span><br><span class="line">| 2021-04-15 22:00:00.000 | 2021-04-15 22:10:00.000 | 2021-04-15 22:09:59.999 |    A |       1.8 |</span><br><span class="line">| 2021-04-15 22:00:00.000 | 2021-04-15 22:10:00.000 | 2021-04-15 22:09:59.999 |    B |       2.5 |</span><br><span class="line">| 2021-04-15 22:00:00.000 | 2021-04-15 22:10:00.000 | 2021-04-15 22:09:59.999 |    C |       3.8 |</span><br><span class="line">+-------------------------+-------------------------+-------------------------+------+-----------+</span><br></pre></td></tr></table></figure>

<h3 id="夏令时支持"><a href="#夏令时支持" class="headerlink" title="夏令时支持"></a>夏令时支持</h3><p>Flink SQL支持在 TIMESTAMP_LTZ列上定义时间属性, 基于这一特征,Flink SQL 在窗口中使用 TIMESTAMP 和 TIMESTAMP_LTZ 类型优雅地支持了夏令时.</p>
<p>Flink 使用时间戳的字符格式来分割窗口并通过每条记录对应的 epoch 时间来分配窗口.<br>这意味着 Flink 窗口开始时间和窗口结束时间使用的是 TIMESTAMP 类型(例如: TUMBLE_START 和 TUMBLE_END), 窗口的时间属性使用的是 TIMESTAMP_LTZ 类型(例如: TUMBLE_PROCTIME, TUMBLE_ROWTIME).<br>给定一个 tumble window示例, 在 Los_Angeles 时区下夏令时从 2021-03-14 02:00:00 开始:<br>long epoch1 = 1615708800000L; // 2021-03-14 00:00:00<br>long epoch2 = 1615712400000L; // 2021-03-14 01:00:00<br>long epoch3 = 1615716000000L; // 2021-03-14 03:00:00, 手表往前拨一小时,跳过 (2021-03-14 02:00:00)<br>long epoch4 = 1615719600000L; // 2021-03-14 04:00:00 </p>
<p>在 Los_angele 时区下, tumble window [2021-03-14 00:00:00, 2021-03-14 00:04:00] 将会收集3个小时的数据, 在其他非夏令时的时区下将会收集4个小时的数据,用户只需要在 TIMESTAMP_LTZ 列上声明时间属性即可.</p>
<p>Flink 的所有窗口(如 Hop window, Session window, Cumulative window)都会遵循这种方式, Flink SQL 中的所有操作都很好地支持了 TIMESTAMP_LTZ 类型,因此Flink可以非常优雅的支持夏令时.</p>
<h3 id="Batch-模式和-Streaming-模式的区别"><a href="#Batch-模式和-Streaming-模式的区别" class="headerlink" title="Batch 模式和 Streaming 模式的区别"></a>Batch 模式和 Streaming 模式的区别</h3><p>以下函数:<br>LOCALTIME<br>LOCALTIMESTAMP<br>CURRENT_DATE<br>CURRENT_TIME<br>CURRENT_TIMESTAMP<br>NOW()<br>Flink 会根据执行模式来进行不同计算,在 Streaming 模式下这些函数是每条记录都会计算一次,但在 Batch 模式下,只会在 query 开始时计算一次,所有记录都使用相同的结果.</p>
<p>以下时间函数无论是在 Streaming 模式还是 Batch 模式下,都会为每条记录计算一次结果:<br>CURRENT_ROW_TIMESTAMP()<br>PROCTIME()</p>
<h2 id="Table-API-1"><a href="#Table-API-1" class="headerlink" title="Table API"></a>Table API</h2><p>Table API 是批处理和流处理的统一的关系型 API.<br>Table API 的查询不需要修改代码就可以采用批输入或流输入来运行.<br>Table API 是 SQL 语言的超集,并且是针对 Apache Flink 专门设计的.<br>Table API 集成了 Scala,Java 和 Python 语言的 API.<br>Table API 的查询是使用 Java,Scala 或 Python 语言嵌入的风格定义的,有诸如自动补全和语法校验的 IDE 支持,而不是像普通 SQL 一样使用字符串类型的值来指定查询.</p>
<p>Table API 和 Flink SQL 共享许多概念以及部分集成的 API.<br>通过查看公共概念 &amp; API来学习如何注册表或如何创建一个表对象.<br>流概念页面讨论了诸如动态表和时间属性等流特有的概念.</p>
<p>下面的例子中假定有一张叫 Orders 的表,表中有属性 (a, b, c, rowtime) .<br>rowtime 字段是流任务中的逻辑时间属性或是批任务中的普通时间戳字段.</p>
<h3 id="概述-amp-示例"><a href="#概述-amp-示例" class="headerlink" title="概述 &amp; 示例"></a>概述 &amp; 示例</h3><p>Table API 支持 Scala, Java 和 Python 语言.<br>Scala 语言的 Table API 利用了 Scala 表达式,Java 语言的 Table API 支持 DSL 表达式和解析并转换为等价表达式的字符串,Python 语言的 Table API 仅支持解析并转换为等价表达式的字符串.</p>
<p>下面的例子展示了 Scala/Java 和 Python 语言的 Table API 的不同之处.<br>表程序是在批环境下执行的.<br>程序扫描了 Orders 表,通过字段 a 进行分组,并计算了每组结果的行数.</p>
<p>Java 的 Table API 通过引入 org.apache.flink.table.api.java.* 来使用.<br>下面的例子展示了如何创建一个 Java 的 Table API 程序,以及表达式是如何指定为字符串的.<br>使用DSL表达式时也需要引入静态的 org.apache.flink.table.api.Expressions.*.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.table.api.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.apache.flink.table.api.Expressions.*;</span><br><span class="line"></span><br><span class="line">EnvironmentSettings settings = EnvironmentSettings</span><br><span class="line">  .newInstance()</span><br><span class="line">  .inStreamingMode()</span><br><span class="line">  .build();</span><br><span class="line"></span><br><span class="line">TableEnvironment tEnv = TableEnvironment.create(settings);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在表环境中注册 Orders 表</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定表程序</span></span><br><span class="line">Table orders = tEnv.from(<span class="string">&quot;Orders&quot;</span>); <span class="comment">// schema (a, b, c, rowtime)</span></span><br><span class="line"></span><br><span class="line">Table counts = orders</span><br><span class="line">  .groupBy($(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">  .select($(<span class="string">&quot;a&quot;</span>), $(<span class="string">&quot;b&quot;</span>).count().as(<span class="string">&quot;cnt&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line">counts.execute().print();</span><br></pre></td></tr></table></figure>

<p>下一个例子展示了一个更加复杂的 Table API 程序.<br>这个程序也扫描 Orders 表.<br>程序过滤了空值,使字符串类型的字段 a 标准化,并且每个小时进行一次计算并返回 a 的平均账单金额 b.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 环境配置</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定表程序</span></span><br><span class="line">Table orders = tEnv.from(<span class="string">&quot;Orders&quot;</span>); <span class="comment">// schema (a, b, c, rowtime)</span></span><br><span class="line"></span><br><span class="line">Table result = orders</span><br><span class="line">  .filter(</span><br><span class="line">      and(</span><br><span class="line">          $(<span class="string">&quot;a&quot;</span>).isNotNull(),</span><br><span class="line">          $(<span class="string">&quot;b&quot;</span>).isNotNull(),</span><br><span class="line">          $(<span class="string">&quot;c&quot;</span>).isNotNull()</span><br><span class="line">      ))</span><br><span class="line">  .select($(<span class="string">&quot;a&quot;</span>).lowerCase().as(<span class="string">&quot;a&quot;</span>), $(<span class="string">&quot;b&quot;</span>), $(<span class="string">&quot;rowtime&quot;</span>))</span><br><span class="line">  .window(Tumble.over(lit(<span class="number">1</span>).hours()).on($(<span class="string">&quot;rowtime&quot;</span>)).as(<span class="string">&quot;hourlyWindow&quot;</span>))</span><br><span class="line">  .groupBy($(<span class="string">&quot;hourlyWindow&quot;</span>), $(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">  .select($(<span class="string">&quot;a&quot;</span>), $(<span class="string">&quot;hourlyWindow&quot;</span>).end().as(<span class="string">&quot;hour&quot;</span>), $(<span class="string">&quot;b&quot;</span>).avg().as(<span class="string">&quot;avgBillingAmount&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>因为 Table API 的批数据 API 和流数据 API 是统一的,所以这两个例子程序不需要修改代码就可以运行在流输入或批输入上.<br>在这两种情况下,只要流任务没有数据延时,程序将会输出相同的结果(查看流概念获取详情).</p>
<h3 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h3><p>Table API支持如下操作.<br>请注意不是所有的操作都可以既支持流也支持批.<br>这些操作都具有相应的标记.</p>
<h4 id="Scan-Projection-and-Filter"><a href="#Scan-Projection-and-Filter" class="headerlink" title="Scan, Projection, and Filter"></a>Scan, Projection, and Filter</h4><h5 id="From"><a href="#From" class="headerlink" title="From"></a>From</h5><p>Batch Streaming</p>
<p>和 SQL 查询的 FROM 子句类似.<br>执行一个注册过的表的扫描.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Table orders = tableEnv.from(<span class="string">&quot;Orders&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="FromValues"><a href="#FromValues" class="headerlink" title="FromValues"></a>FromValues</h5><p>Batch Streaming</p>
<p>和 SQL 查询中的 VALUES 子句类似.<br>基于提供的行生成一张内联表.</p>
<p>你可以使用 row(...) 表达式创建复合行:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Table table = tEnv.fromValues(</span><br><span class="line">  row(<span class="number">1</span>, <span class="string">&quot;ABC&quot;</span>),</span><br><span class="line">  row(<span class="number">2L</span>, <span class="string">&quot;ABCDE&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这将生成一张结构如下的表:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line">|-- f0: BIGINT NOT NULL     &#x2F;&#x2F; original types INT and BIGINT are generalized to BIGINT</span><br><span class="line">|-- f1: VARCHAR(5) NOT NULL &#x2F;&#x2F; original types CHAR(3) and CHAR(5) are generalized</span><br><span class="line">                          &#x2F;&#x2F; to VARCHAR(5). VARCHAR is used instead of CHAR so that</span><br><span class="line">                          &#x2F;&#x2F; no padding is applied</span><br></pre></td></tr></table></figure>

<p>这个方法会根据输入的表达式自动获取类型.<br>如果在某一个特定位置的类型不一致,该方法会尝试寻找一个所有类型的公共超类型.<br>如果公共超类型不存在,则会抛出异常.</p>
<p>你也可以明确指定所需的类型.<br>指定如 DECIMAL 这样的一般类型或者给列命名可能是有帮助的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Table table = tEnv.fromValues(</span><br><span class="line">  DataTypes.ROW(</span><br><span class="line">      DataTypes.FIELD(<span class="string">&quot;id&quot;</span>, DataTypes.DECIMAL(<span class="number">10</span>, <span class="number">2</span>)),</span><br><span class="line">      DataTypes.FIELD(<span class="string">&quot;name&quot;</span>, DataTypes.STRING())</span><br><span class="line">  ),</span><br><span class="line">  row(<span class="number">1</span>, <span class="string">&quot;ABC&quot;</span>),</span><br><span class="line">  row(<span class="number">2L</span>, <span class="string">&quot;ABCDE&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这将生成一张结构如下的表:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line">|-- id: DECIMAL(10, 2)</span><br><span class="line">|-- name: STRING</span><br></pre></td></tr></table></figure>

<h5 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h5><p>Batch Streaming</p>
<p>和 SQL 的 SELECT 子句类似.<br>执行一个 select 操作.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Table orders = tableEnv.from(<span class="string">&quot;Orders&quot;</span>);</span><br><span class="line">Table result = orders.select($(<span class="string">&quot;a&quot;</span>), $(<span class="string">&quot;c&quot;</span>).as(<span class="string">&quot;d&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>你可以选择星号(*)作为通配符,select 表中的所有列.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Table result = orders.select($(<span class="string">&quot;*&quot;</span>));</span><br></pre></td></tr></table></figure>

<h5 id="As"><a href="#As" class="headerlink" title="As"></a>As</h5><p>Batch Streaming</p>
<p>重命名字段.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Table orders = tableEnv.from(<span class="string">&quot;Orders&quot;</span>);</span><br><span class="line">Table result = orders.as(<span class="string">&quot;x, y, z, t&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="Where-Filter"><a href="#Where-Filter" class="headerlink" title="Where / Filter"></a>Where / Filter</h5><p>Batch Streaming</p>
<p>和 SQL 的 WHERE 子句类似.<br>过滤掉未验证通过过滤谓词的行.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Table orders = tableEnv.from(<span class="string">&quot;Orders&quot;</span>);</span><br><span class="line">Table result = orders.where($(<span class="string">&quot;b&quot;</span>).isEqual(<span class="string">&quot;red&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Table orders = tableEnv.from(<span class="string">&quot;Orders&quot;</span>);</span><br><span class="line">Table result = orders.filter($(<span class="string">&quot;b&quot;</span>).isEqual(<span class="string">&quot;red&quot;</span>));</span><br></pre></td></tr></table></figure>

<h4 id="列操作"><a href="#列操作" class="headerlink" title="列操作"></a>列操作</h4><h5 id="AddColumns"><a href="#AddColumns" class="headerlink" title="AddColumns"></a>AddColumns</h5><p>Batch Streaming</p>
<p>执行字段添加操作.<br>如果所添加的字段已经存在,将抛出异常.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Table orders = tableEnv.from(<span class="string">&quot;Orders&quot;</span>);</span><br><span class="line">Table result = orders.addColumns(concat($(<span class="string">&quot;c&quot;</span>), <span class="string">&quot;sunny&quot;</span>));</span><br></pre></td></tr></table></figure>

<h5 id="AddOrReplaceColumns"><a href="#AddOrReplaceColumns" class="headerlink" title="AddOrReplaceColumns"></a>AddOrReplaceColumns</h5><p>Batch Streaming</p>
<p>执行字段添加操作.<br>如果添加的列名称和已存在的列名称相同,则已存在的字段将被替换.<br>此外,如果添加的字段里面有重复的字段名,则会使用最后一个字段.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Table orders = tableEnv.from(<span class="string">&quot;Orders&quot;</span>);</span><br><span class="line">Table result = orders.addOrReplaceColumns(concat($(<span class="string">&quot;c&quot;</span>), <span class="string">&quot;sunny&quot;</span>).as(<span class="string">&quot;desc&quot;</span>));</span><br></pre></td></tr></table></figure>

<h5 id="DropColumns"><a href="#DropColumns" class="headerlink" title="DropColumns"></a>DropColumns</h5><p>Batch Streaming</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Table orders = tableEnv.from(<span class="string">&quot;Orders&quot;</span>);</span><br><span class="line">Table result = orders.dropColumns($(<span class="string">&quot;b&quot;</span>), $(<span class="string">&quot;c&quot;</span>));</span><br></pre></td></tr></table></figure>

<h5 id="RenameColumns"><a href="#RenameColumns" class="headerlink" title="RenameColumns"></a>RenameColumns</h5><p>Batch Streaming</p>
<p>执行字段重命名操作.<br>字段表达式应该是别名表达式,并且仅当字段已存在时才能被重命名.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Table orders = tableEnv.from(<span class="string">&quot;Orders&quot;</span>);</span><br><span class="line">Table result = orders.renameColumns($(<span class="string">&quot;b&quot;</span>).as(<span class="string">&quot;b2&quot;</span>), $(<span class="string">&quot;c&quot;</span>).as(<span class="string">&quot;c2&quot;</span>));</span><br></pre></td></tr></table></figure>

<h5 id="Aggregations"><a href="#Aggregations" class="headerlink" title="Aggregations"></a>Aggregations</h5><p>GroupBy Aggregation<br>Batch Streaming Result Updating</p>
<p>和 SQL 的 GROUP BY 子句类似.<br>使用分组键对行进行分组,使用伴随的聚合算子来按照组进行聚合行.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Table orders = tableEnv.from(<span class="string">&quot;Orders&quot;</span>);</span><br><span class="line">Table result = orders.groupBy($(<span class="string">&quot;a&quot;</span>)).select($(<span class="string">&quot;a&quot;</span>), $(<span class="string">&quot;b&quot;</span>).sum().as(<span class="string">&quot;d&quot;</span>));</span><br></pre></td></tr></table></figure>

<h5 id="GroupBy-Window-Aggregation"><a href="#GroupBy-Window-Aggregation" class="headerlink" title="GroupBy Window Aggregation"></a>GroupBy Window Aggregation</h5><p>Batch Streaming</p>
<p>使用分组窗口结合单个或者多个分组键对表进行分组和聚合.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Table orders = tableEnv.from(<span class="string">&quot;Orders&quot;</span>);</span><br><span class="line">Table result = orders</span><br><span class="line">  .window(Tumble.over(lit(<span class="number">5</span>).minutes()).on($(<span class="string">&quot;rowtime&quot;</span>)).as(<span class="string">&quot;w&quot;</span>)) <span class="comment">// 定义窗口</span></span><br><span class="line">  .groupBy($(<span class="string">&quot;a&quot;</span>), $(<span class="string">&quot;w&quot;</span>)) <span class="comment">// 按窗口和键分组</span></span><br><span class="line">  <span class="comment">// 访问窗口属性并聚合</span></span><br><span class="line">  .select(</span><br><span class="line">    $(<span class="string">&quot;a&quot;</span>),</span><br><span class="line">    $(<span class="string">&quot;w&quot;</span>).start(),</span><br><span class="line">    $(<span class="string">&quot;w&quot;</span>).end(),</span><br><span class="line">    $(<span class="string">&quot;w&quot;</span>).rowtime(),</span><br><span class="line">    $(<span class="string">&quot;b&quot;</span>).sum().as(<span class="string">&quot;d&quot;</span>)</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>

<h5 id="Over-Window-Aggregation"><a href="#Over-Window-Aggregation" class="headerlink" title="Over Window Aggregation"></a>Over Window Aggregation</h5><p>和 SQL 的 OVER 子句类似.<br>更多细节详见 over windows section</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Table orders = tableEnv.from(<span class="string">&quot;Orders&quot;</span>);</span><br><span class="line">Table result = orders</span><br><span class="line">  <span class="comment">// 定义窗口</span></span><br><span class="line">  .window(</span><br><span class="line">    Over</span><br><span class="line">      .partitionBy($(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">      .orderBy($(<span class="string">&quot;rowtime&quot;</span>))</span><br><span class="line">      .preceding(UNBOUNDED_RANGE)</span><br><span class="line">      .following(CURRENT_RANGE)</span><br><span class="line">      .as(<span class="string">&quot;w&quot;</span>))</span><br><span class="line">  <span class="comment">// 滑动聚合</span></span><br><span class="line">  .select(</span><br><span class="line">    $(<span class="string">&quot;a&quot;</span>),</span><br><span class="line">    $(<span class="string">&quot;b&quot;</span>).avg().over($(<span class="string">&quot;w&quot;</span>)),</span><br><span class="line">    $(<span class="string">&quot;b&quot;</span>).max().over($(<span class="string">&quot;w&quot;</span>)),</span><br><span class="line">    $(<span class="string">&quot;b&quot;</span>).min().over($(<span class="string">&quot;w&quot;</span>))</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>

<p>所有的聚合必须定义在同一个窗口上,比如同一个分区/排序和范围内.<br>目前只支持 PRECEDING 到当前行范围(无界或有界)的窗口.<br>尚不支持 FOLLOWING 范围的窗口.<br>ORDER BY 操作必须指定一个单一的时间属性.</p>
<h5 id="Distinct-Aggregation"><a href="#Distinct-Aggregation" class="headerlink" title="Distinct Aggregation"></a>Distinct Aggregation</h5><p>Batch Streaming Result-Updating</p>
<p>和 SQL DISTINCT 聚合子句类似,例如 COUNT(DISTINCT a).<br>Distinct 聚合声明的聚合函数(内置或用户定义的)仅应用于互不相同的输入值.<br>Distinct 可以应用于 <strong>GroupBy Aggregation</strong>/<strong>GroupBy Window Aggregation</strong> 和 <strong>Over Window Aggregation</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Table orders = tableEnv.from(<span class="string">&quot;Orders&quot;</span>);</span><br><span class="line"><span class="comment">// 按属性分组后的的互异(互不相同/去重)聚合</span></span><br><span class="line">Table groupByDistinctResult = orders</span><br><span class="line">  .groupBy($(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">  .select($(<span class="string">&quot;a&quot;</span>), $(<span class="string">&quot;b&quot;</span>).sum().distinct().as(<span class="string">&quot;d&quot;</span>));</span><br><span class="line"><span class="comment">// 按属性/时间窗口分组后的互异(互不相同/去重)聚合</span></span><br><span class="line">Table groupByWindowDistinctResult = orders</span><br><span class="line">  .window(Tumble</span><br><span class="line">      .over(lit(<span class="number">5</span>).minutes())</span><br><span class="line">      .on($(<span class="string">&quot;rowtime&quot;</span>))</span><br><span class="line">      .as(<span class="string">&quot;w&quot;</span>)</span><br><span class="line">  )</span><br><span class="line">  .groupBy($(<span class="string">&quot;a&quot;</span>), $(<span class="string">&quot;w&quot;</span>))</span><br><span class="line">  .select($(<span class="string">&quot;a&quot;</span>), $(<span class="string">&quot;b&quot;</span>).sum().distinct().as(<span class="string">&quot;d&quot;</span>));</span><br><span class="line"><span class="comment">// over window 上的互异(互不相同/去重)聚合</span></span><br><span class="line">Table result = orders</span><br><span class="line">  .window(Over</span><br><span class="line">      .partitionBy($(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">      .orderBy($(<span class="string">&quot;rowtime&quot;</span>))</span><br><span class="line">      .preceding(UNBOUNDED_RANGE)</span><br><span class="line">      .as(<span class="string">&quot;w&quot;</span>))</span><br><span class="line">  .select(</span><br><span class="line">      $(<span class="string">&quot;a&quot;</span>), $(<span class="string">&quot;b&quot;</span>).avg().distinct().over($(<span class="string">&quot;w&quot;</span>)),</span><br><span class="line">      $(<span class="string">&quot;b&quot;</span>).max().over($(<span class="string">&quot;w&quot;</span>)),</span><br><span class="line">      $(<span class="string">&quot;b&quot;</span>).min().over($(<span class="string">&quot;w&quot;</span>))</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>

<p>用户定义的聚合函数也可以与 DISTINCT 修饰符一起使用.<br>如果计算不同(互异/去重的)值的聚合结果,则只需向聚合函数添加 distinct 修饰符即可.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Table orders = tEnv.from(<span class="string">&quot;Orders&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 user-defined aggregate functions 使用互异(互不相同/去重)聚合</span></span><br><span class="line">tEnv.registerFunction(<span class="string">&quot;myUdagg&quot;</span>, <span class="keyword">new</span> MyUdagg());</span><br><span class="line">orders.groupBy(<span class="string">&quot;users&quot;</span>)</span><br><span class="line">  .select(</span><br><span class="line">      $(<span class="string">&quot;users&quot;</span>),</span><br><span class="line">      call(<span class="string">&quot;myUdagg&quot;</span>, $(<span class="string">&quot;points&quot;</span>)).distinct().as(<span class="string">&quot;myDistinctResult&quot;</span>)</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>

<h5 id="Distinct"><a href="#Distinct" class="headerlink" title="Distinct"></a>Distinct</h5><p>Batch Streaming Result-Updating</p>
<p>和 SQL 的 DISTINCT 子句类似.<br>返回具有不同组合值的记录.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Table orders = tableEnv.from(<span class="string">&quot;Orders&quot;</span>);</span><br><span class="line">Table result = orders.distinct();</span><br></pre></td></tr></table></figure>

<h4 id="Joins"><a href="#Joins" class="headerlink" title="Joins"></a>Joins</h4><h5 id="Inner-Join"><a href="#Inner-Join" class="headerlink" title="Inner Join"></a>Inner Join</h5><p>Batch Streaming</p>
<p>和 SQL 的 JOIN 子句类似.<br>关联两张表.<br>两张表必须有不同的字段名,并且必须通过 join 算子或者使用 where 或 filter 算子定义至少一个 join 等式连接谓词.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Table left = tableEnv.from(<span class="string">&quot;MyTable&quot;</span>).select($(<span class="string">&quot;a&quot;</span>), $(<span class="string">&quot;b&quot;</span>), $(<span class="string">&quot;c&quot;</span>));</span><br><span class="line">Table right = tableEnv.from(<span class="string">&quot;MyTable&quot;</span>).select($(<span class="string">&quot;d&quot;</span>), $(<span class="string">&quot;e&quot;</span>), $(<span class="string">&quot;f&quot;</span>));</span><br><span class="line">Table result = left.join(right)</span><br><span class="line">  .where($(<span class="string">&quot;a&quot;</span>).isEqual($(<span class="string">&quot;d&quot;</span>)))</span><br><span class="line">  .select($(<span class="string">&quot;a&quot;</span>), $(<span class="string">&quot;b&quot;</span>), $(<span class="string">&quot;e&quot;</span>));</span><br></pre></td></tr></table></figure>

<h5 id="Outer-Join"><a href="#Outer-Join" class="headerlink" title="Outer Join"></a>Outer Join</h5><p>Batch Streaming Result-Updating</p>
<p>和 SQL LEFT/RIGHT/FULL OUTER JOIN 子句类似.<br>关联两张表.<br>两张表必须有不同的字段名,并且必须定义至少一个等式连接谓词.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Table left = tableEnv.from(<span class="string">&quot;MyTable&quot;</span>).select($(<span class="string">&quot;a&quot;</span>), $(<span class="string">&quot;b&quot;</span>), $(<span class="string">&quot;c&quot;</span>));</span><br><span class="line">Table right = tableEnv.from(<span class="string">&quot;MyTable&quot;</span>).select($(<span class="string">&quot;d&quot;</span>), $(<span class="string">&quot;e&quot;</span>), $(<span class="string">&quot;f&quot;</span>));</span><br><span class="line"></span><br><span class="line">Table leftOuterResult = left.leftOuterJoin(right, $(<span class="string">&quot;a&quot;</span>).isEqual($(<span class="string">&quot;d&quot;</span>)))</span><br><span class="line">                          .select($(<span class="string">&quot;a&quot;</span>), $(<span class="string">&quot;b&quot;</span>), $(<span class="string">&quot;e&quot;</span>));</span><br><span class="line">Table rightOuterResult = left.rightOuterJoin(right, $(<span class="string">&quot;a&quot;</span>).isEqual($(<span class="string">&quot;d&quot;</span>)))</span><br><span class="line">                          .select($(<span class="string">&quot;a&quot;</span>), $(<span class="string">&quot;b&quot;</span>), $(<span class="string">&quot;e&quot;</span>));</span><br><span class="line">Table fullOuterResult = left.fullOuterJoin(right, $(<span class="string">&quot;a&quot;</span>).isEqual($(<span class="string">&quot;d&quot;</span>)))</span><br><span class="line">                          .select($(<span class="string">&quot;a&quot;</span>), $(<span class="string">&quot;b&quot;</span>), $(<span class="string">&quot;e&quot;</span>));</span><br></pre></td></tr></table></figure>

<h5 id="Interval-Join"><a href="#Interval-Join" class="headerlink" title="Interval Join"></a>Interval Join</h5><p>Batch Streaming</p>
<p>Interval join 是可以通过流模式处理的常规 join 的子集.</p>
<p>Interval join 至少需要一个 equi-join 谓词和一个限制双方时间界限的 join 条件.<br>这种条件可以由两个合适的范围谓词(&lt;/&lt;=/&gt;=/&gt;)或一个比较两个输入表相同时间属性(即处理时间或事件时间)的等值谓词来定义.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Table left = tableEnv.from(<span class="string">&quot;MyTable&quot;</span>).select($(<span class="string">&quot;a&quot;</span>), $(<span class="string">&quot;b&quot;</span>), $(<span class="string">&quot;c&quot;</span>), $(<span class="string">&quot;ltime&quot;</span>));</span><br><span class="line">Table right = tableEnv.from(<span class="string">&quot;MyTable&quot;</span>).select($(<span class="string">&quot;d&quot;</span>), $(<span class="string">&quot;e&quot;</span>), $(<span class="string">&quot;f&quot;</span>), $(<span class="string">&quot;rtime&quot;</span>));</span><br><span class="line"></span><br><span class="line">Table result = left.join(right)</span><br><span class="line"> .where(</span><br><span class="line">  and(</span><br><span class="line">      $(<span class="string">&quot;a&quot;</span>).isEqual($(<span class="string">&quot;d&quot;</span>)),</span><br><span class="line">      $(<span class="string">&quot;ltime&quot;</span>).isGreaterOrEqual($(<span class="string">&quot;rtime&quot;</span>).minus(lit(<span class="number">5</span>).minutes())),</span><br><span class="line">      $(<span class="string">&quot;ltime&quot;</span>).isLess($(<span class="string">&quot;rtime&quot;</span>).plus(lit(<span class="number">10</span>).minutes()))</span><br><span class="line">  ))</span><br><span class="line"> .select($(<span class="string">&quot;a&quot;</span>), $(<span class="string">&quot;b&quot;</span>), $(<span class="string">&quot;e&quot;</span>), $(<span class="string">&quot;ltime&quot;</span>));</span><br></pre></td></tr></table></figure>

<h5 id="Inner-Join-with-Table-Function-UDTF"><a href="#Inner-Join-with-Table-Function-UDTF" class="headerlink" title="Inner Join with Table Function (UDTF)"></a>Inner Join with Table Function (UDTF)</h5><p>Batch Streaming</p>
<p>join 表和表函数的结果.<br>左(外部)表的每一行都会 join 表函数相应调用产生的所有行.<br>如果表函数调用返回空结果,则删除左侧(外部)表的一行.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册 User-Defined Table Function</span></span><br><span class="line">TableFunction&lt;Tuple3&lt;String,String,String&gt;&gt; split = <span class="keyword">new</span> MySplitUDTF();</span><br><span class="line">tableEnv.registerFunction(<span class="string">&quot;split&quot;</span>, split);</span><br><span class="line"></span><br><span class="line"><span class="comment">// join</span></span><br><span class="line">Table orders = tableEnv.from(<span class="string">&quot;Orders&quot;</span>);</span><br><span class="line">Table result = orders</span><br><span class="line">  .joinLateral(call(<span class="string">&quot;split&quot;</span>, $(<span class="string">&quot;c&quot;</span>)).as(<span class="string">&quot;s&quot;</span>, <span class="string">&quot;t&quot;</span>, <span class="string">&quot;v&quot;</span>))</span><br><span class="line">  .select($(<span class="string">&quot;a&quot;</span>), $(<span class="string">&quot;b&quot;</span>), $(<span class="string">&quot;s&quot;</span>), $(<span class="string">&quot;t&quot;</span>), $(<span class="string">&quot;v&quot;</span>));</span><br></pre></td></tr></table></figure>

<h5 id="Left-Outer-Join-with-Table-Function-UDTF"><a href="#Left-Outer-Join-with-Table-Function-UDTF" class="headerlink" title="Left Outer Join with Table Function (UDTF)"></a>Left Outer Join with Table Function (UDTF)</h5><p>Batch Streaming</p>
<p>join 表和表函数的结果.<br>左(外部)表的每一行都会 join 表函数相应调用产生的所有行.<br>如果表函数调用返回空结果,则保留相应的 outer(外部连接)行并用空值填充右侧结果.</p>
<p>目前,表函数左外连接的谓词只能为空或字面(常量)真.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册 User-Defined Table Function</span></span><br><span class="line">TableFunction&lt;Tuple3&lt;String,String,String&gt;&gt; split = <span class="keyword">new</span> MySplitUDTF();</span><br><span class="line">tableEnv.registerFunction(<span class="string">&quot;split&quot;</span>, split);</span><br><span class="line"></span><br><span class="line"><span class="comment">// join</span></span><br><span class="line">Table orders = tableEnv.from(<span class="string">&quot;Orders&quot;</span>);</span><br><span class="line">Table result = orders</span><br><span class="line">  .leftOuterJoinLateral(call(<span class="string">&quot;split&quot;</span>, $(<span class="string">&quot;c&quot;</span>)).as(<span class="string">&quot;s&quot;</span>, <span class="string">&quot;t&quot;</span>, <span class="string">&quot;v&quot;</span>))</span><br><span class="line">  .select($(<span class="string">&quot;a&quot;</span>), $(<span class="string">&quot;b&quot;</span>), $(<span class="string">&quot;s&quot;</span>), $(<span class="string">&quot;t&quot;</span>), $(<span class="string">&quot;v&quot;</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Join with Temporal Table</p>
</blockquote>
<p>Temporal table 是跟踪随时间变化的表.</p>
<p>Temporal table 函数提供对特定时间点 temporal table 状态的访问.<br>表与 temporal table 函数进行 join 的语法和使用表函数进行 inner join 的语法相同.</p>
<p>目前仅支持与 temporal table 的 inner join.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Table ratesHistory = tableEnv.from(<span class="string">&quot;RatesHistory&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册带有时间属性和主键的 temporal table function</span></span><br><span class="line">TemporalTableFunction rates = ratesHistory.createTemporalTableFunction(</span><br><span class="line">  <span class="string">&quot;r_proctime&quot;</span>,</span><br><span class="line">  <span class="string">&quot;r_currency&quot;</span>);</span><br><span class="line">tableEnv.registerFunction(<span class="string">&quot;rates&quot;</span>, rates);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于时间属性和键与&quot;Orders&quot;表关联</span></span><br><span class="line">Table orders = tableEnv.from(<span class="string">&quot;Orders&quot;</span>);</span><br><span class="line">Table result = orders</span><br><span class="line">  .joinLateral(call(<span class="string">&quot;rates&quot;</span>, $(<span class="string">&quot;o_proctime&quot;</span>)), $(<span class="string">&quot;o_currency&quot;</span>).isEqual($(<span class="string">&quot;r_currency&quot;</span>)));</span><br></pre></td></tr></table></figure>

<h4 id="Set-Operations"><a href="#Set-Operations" class="headerlink" title="Set Operations"></a>Set Operations</h4><h5 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h5><p>Batch<br>和 SQL UNION 子句类似.<br>Union 两张表会删除重复记录.<br>两张表必须具有相同的字段类型.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Table left = tableEnv.from(<span class="string">&quot;orders1&quot;</span>);</span><br><span class="line">Table right = tableEnv.from(<span class="string">&quot;orders2&quot;</span>);</span><br><span class="line"></span><br><span class="line">left.union(right);</span><br></pre></td></tr></table></figure>

<h5 id="UnionAll"><a href="#UnionAll" class="headerlink" title="UnionAll"></a>UnionAll</h5><p>Batch Streaming</p>
<p>和 SQL UNION ALL 子句类似.<br>Union 两张表.<br>两张表必须具有相同的字段类型.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Table left = tableEnv.from(<span class="string">&quot;orders1&quot;</span>);</span><br><span class="line">Table right = tableEnv.from(<span class="string">&quot;orders2&quot;</span>);</span><br><span class="line"></span><br><span class="line">left.unionAll(right);</span><br></pre></td></tr></table></figure>

<h5 id="Intersect"><a href="#Intersect" class="headerlink" title="Intersect"></a>Intersect</h5><p>Batch<br>和 SQL INTERSECT 子句类似.<br>Intersect 返回两个表中都存在的记录.<br>如果一条记录在一张或两张表中存在多次,则只返回一条记录,也就是说,结果表中不存在重复的记录.<br>两张表必须具有相同的字段类型.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Table left = tableEnv.from(<span class="string">&quot;orders1&quot;</span>);</span><br><span class="line">Table right = tableEnv.from(<span class="string">&quot;orders2&quot;</span>);</span><br><span class="line"></span><br><span class="line">left.intersect(right);</span><br></pre></td></tr></table></figure>

<h5 id="IntersectAll"><a href="#IntersectAll" class="headerlink" title="IntersectAll"></a>IntersectAll</h5><p>Batch<br>和 SQL INTERSECT ALL 子句类似.<br>IntersectAll 返回两个表中都存在的记录.<br>如果一条记录在两张表中出现多次,那么该记录返回的次数同该记录在两个表中都出现的次数一致,也就是说,结果表可能存在重复记录.<br>两张表必须具有相同的字段类型.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Table left = tableEnv.from(<span class="string">&quot;orders1&quot;</span>);</span><br><span class="line">Table right = tableEnv.from(<span class="string">&quot;orders2&quot;</span>);</span><br><span class="line"></span><br><span class="line">left.intersectAll(right);</span><br></pre></td></tr></table></figure>

<h5 id="Minus"><a href="#Minus" class="headerlink" title="Minus"></a>Minus</h5><p>Batch<br>和 SQL EXCEPT 子句类似.<br>Minus 返回左表中存在且右表中不存在的记录.<br>左表中的重复记录只返回一次,换句话说,结果表中没有重复记录.<br>两张表必须具有相同的字段类型.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Table left = tableEnv.from(<span class="string">&quot;orders1&quot;</span>);</span><br><span class="line">Table right = tableEnv.from(<span class="string">&quot;orders2&quot;</span>);</span><br><span class="line"></span><br><span class="line">left.minus(right);</span><br></pre></td></tr></table></figure>

<h5 id="MinusAll"><a href="#MinusAll" class="headerlink" title="MinusAll"></a>MinusAll</h5><p>Batch<br>和 SQL EXCEPT ALL 子句类似.<br>MinusAll 返回右表中不存在的记录.<br>在左表中出现 n 次且在右表中出现 m 次的记录,在结果表中出现 (n - m) 次,例如,也就是说结果中删掉了在右表中存在重复记录的条数的记录.<br>两张表必须具有相同的字段类型.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Table left = tableEnv.from(<span class="string">&quot;orders1&quot;</span>);</span><br><span class="line">Table right = tableEnv.from(<span class="string">&quot;orders2&quot;</span>);</span><br><span class="line"></span><br><span class="line">left.minusAll(right);</span><br></pre></td></tr></table></figure>

<h5 id="In"><a href="#In" class="headerlink" title="In"></a>In</h5><p>Batch Streaming</p>
<p>和 SQL IN 子句类似.<br>如果表达式的值存在于给定表的子查询中,那么 In 子句返回 true.<br>子查询表必须由一列组成.<br>这个列必须与表达式具有相同的数据类型.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Table left = tableEnv.from(<span class="string">&quot;Orders1&quot;</span>)</span><br><span class="line">Table right = tableEnv.from(<span class="string">&quot;Orders2&quot;</span>);</span><br><span class="line"></span><br><span class="line">Table result = left.select($(<span class="string">&quot;a&quot;</span>), $(<span class="string">&quot;b&quot;</span>), $(<span class="string">&quot;c&quot;</span>)).where($(<span class="string">&quot;a&quot;</span>).in(right));</span><br></pre></td></tr></table></figure>

<h4 id="OrderBy-Offset-amp-Fetch"><a href="#OrderBy-Offset-amp-Fetch" class="headerlink" title="OrderBy, Offset &amp; Fetch"></a>OrderBy, Offset &amp; Fetch</h4><h5 id="Order-By"><a href="#Order-By" class="headerlink" title="Order By"></a>Order By</h5><p>Batch Streaming</p>
<p>和 SQL ORDER BY 子句类似.<br>返回跨所有并行分区的全局有序记录.<br>对于无界表,该操作需要对时间属性进行排序或进行后续的 fetch 操作.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Table result = tab.orderBy($(<span class="string">&quot;a&quot;</span>).asc());</span><br></pre></td></tr></table></figure>

<h5 id="Offset-amp-Fetch"><a href="#Offset-amp-Fetch" class="headerlink" title="Offset &amp; Fetch"></a>Offset &amp; Fetch</h5><p>Batch Streaming</p>
<p>和 SQL 的 OFFSET 和 FETCH 子句类似.<br>Offset 操作根据偏移位置来限定(可能是已排序的)结果集.<br>Fetch 操作将(可能已排序的)结果集限制为前 n 行.<br>通常,这两个操作前面都有一个排序操作.<br>对于无界表,offset 操作需要 fetch 操作.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从已排序的结果集中返回前5条记录</span></span><br><span class="line">Table result1 = in.orderBy($(<span class="string">&quot;a&quot;</span>).asc()).fetch(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从已排序的结果集中返回跳过3条记录之后的所有记录</span></span><br><span class="line">Table result2 = in.orderBy($(<span class="string">&quot;a&quot;</span>).asc()).offset(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从已排序的结果集中返回跳过10条记录之后的前5条记录</span></span><br><span class="line">Table result3 = in.orderBy($(<span class="string">&quot;a&quot;</span>).asc()).offset(<span class="number">10</span>).fetch(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h4><p>Batch Streaming</p>
<p>和 SQL 查询中的 INSERT INTO 子句类似,该方法执行对已注册的输出表的插入操作.<br>insertInto() 方法会将 INSERT INTO 转换为一个 TablePipeline.<br>该数据流可以用 TablePipeline.explain() 来解释,用 TablePipeline.execute() 来执行.</p>
<p>输出表必须已注册在 TableEnvironment(详见表连接器)中.<br>此外,已注册表的 schema 必须与查询中的 schema 相匹配.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Table orders = tableEnv.from(<span class="string">&quot;Orders&quot;</span>);</span><br><span class="line">orders.insertInto(<span class="string">&quot;OutOrders&quot;</span>).execute();</span><br></pre></td></tr></table></figure>

<h4 id="Group-Windows"><a href="#Group-Windows" class="headerlink" title="Group Windows"></a>Group Windows</h4><p>Group window 聚合根据时间或行计数间隔将行分为有限组,并为每个分组进行一次聚合函数计算.<br>对于批处理表,窗口是按时间间隔对记录进行分组的便捷方式.</p>
<p>窗口是使用 window(GroupWindow w) 子句定义的,并且需要使用 as 子句来指定别名.<br>为了按窗口对表进行分组,窗口别名的引用必须像常规分组属性一样在 groupBy(...) 子句中.<br>以下示例展示了如何在表上定义窗口聚合.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Table table = input</span><br><span class="line"> .window([GroupWindow w].as(<span class="string">&quot;w&quot;</span>))  <span class="comment">// 定义窗口并指定别名为 w</span></span><br><span class="line"> .groupBy($(<span class="string">&quot;w&quot;</span>))  <span class="comment">// 以窗口 w 对表进行分组</span></span><br><span class="line"> .select($(<span class="string">&quot;b&quot;</span>).sum());  <span class="comment">// 聚合</span></span><br></pre></td></tr></table></figure>

<p>在流环境中,如果窗口聚合除了窗口之外还根据一个或多个属性进行分组,则它们只能并行计算,例如,groupBy(...) 子句引用了一个窗口别名和至少一个附加属性.<br>仅引用窗口别名(例如在上面的示例中)的 groupBy(...) 子句只能由单个非并行任务进行计算.<br>以下示例展示了如何定义有附加分组属性的窗口聚合.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Table table = input</span><br><span class="line"> .window([GroupWindow w].as(<span class="string">&quot;w&quot;</span>))  <span class="comment">// 定义窗口并指定别名为 w</span></span><br><span class="line"> .groupBy($(<span class="string">&quot;w&quot;</span>), $(<span class="string">&quot;a&quot;</span>))  <span class="comment">// 以属性 a 和窗口 w 对表进行分组</span></span><br><span class="line"> .select($(<span class="string">&quot;a&quot;</span>), $(<span class="string">&quot;b&quot;</span>).sum());  <span class="comment">// 聚合</span></span><br></pre></td></tr></table></figure>

<p>时间窗口的开始/结束或行时间戳等窗口属性可以作为窗口别名的属性添加到 select 子句中,如 w.start/w.end 和 w.rowtime.<br>窗口开始和行时间戳是包含的上下窗口边界.<br>相反,窗口结束时间戳是唯一的上窗口边界.<br>例如,从下午 2 点开始的 30 分钟滚动窗口将 &quot;14:00:00.000&quot; 作为开始时间戳,&quot;14:29:59.999&quot; 作为行时间时间戳,&quot;14:30:00.000&quot; 作为结束时间戳.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Table table = input</span><br><span class="line"> .window([GroupWindow w].as(<span class="string">&quot;w&quot;</span>))  <span class="comment">// 定义窗口并指定别名为 w</span></span><br><span class="line"> .groupBy($(<span class="string">&quot;w&quot;</span>), $(<span class="string">&quot;a&quot;</span>))  <span class="comment">// 以属性 a 和窗口 w 对表进行分组</span></span><br><span class="line"> .select($(<span class="string">&quot;a&quot;</span>), $(<span class="string">&quot;w&quot;</span>).start(), $(<span class="string">&quot;w&quot;</span>).end(), $(<span class="string">&quot;w&quot;</span>).rowtime(), $(<span class="string">&quot;b&quot;</span>).count()); <span class="comment">// 聚合并添加窗口开始/结束和 rowtime 时间戳</span></span><br></pre></td></tr></table></figure>

<p>Window 参数定义了如何将行映射到窗口.<br>Window 不是用户可以实现的接口.<br>相反,Table API 提供了一组具有特定语义的预定义 Window 类.<br>下面列出了支持的窗口定义.</p>
<h5 id="Tumble-Tumbling-Windows"><a href="#Tumble-Tumbling-Windows" class="headerlink" title="Tumble (Tumbling Windows)"></a>Tumble (Tumbling Windows)</h5><p>滚动窗口将行分配给固定长度的非重叠连续窗口.<br>例如,一个 5 分钟的滚动窗口以 5 分钟的间隔对行进行分组.<br>滚动窗口可以定义在事件时间/处理时间或行数上.</p>
<p>滚动窗口是通过 Tumble 类定义的,具体如下,<br>over:<br>将窗口的长度定义为时间或行计数间隔.</p>
<p>on:<br>要对数据进行分组(时间间隔)或排序(行计数)的时间属性.<br>批处理查询支持任意 Long 或 Timestamp 类型的属性.<br>流处理查询仅支持声明的事件时间或处理时间属性.</p>
<p>as:<br>指定窗口的别名.<br>别名用于在 groupBy() 子句中引用窗口,并可以在 select() 子句中选择如窗口开始/结束或行时间戳的窗口属性.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tumbling Event-time Window</span></span><br><span class="line">.window(Tumble.over(lit(<span class="number">10</span>).minutes()).on($(<span class="string">&quot;rowtime&quot;</span>)).as(<span class="string">&quot;w&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tumbling Processing-time Window (assuming a processing-time attribute &quot;proctime&quot;)</span></span><br><span class="line">.window(Tumble.over(lit(<span class="number">10</span>).minutes()).on($(<span class="string">&quot;proctime&quot;</span>)).as(<span class="string">&quot;w&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tumbling Row-count Window (assuming a processing-time attribute &quot;proctime&quot;)</span></span><br><span class="line">.window(Tumble.over(rowInterval(<span class="number">10</span>)).on($(<span class="string">&quot;proctime&quot;</span>)).as(<span class="string">&quot;w&quot;</span>));</span><br></pre></td></tr></table></figure>

<h5 id="Slide-Sliding-Windows"><a href="#Slide-Sliding-Windows" class="headerlink" title="Slide (Sliding Windows)"></a>Slide (Sliding Windows)</h5><p>滑动窗口具有固定大小并按指定的滑动间隔滑动.<br>如果滑动间隔小于窗口大小,则滑动窗口重叠.<br>因此,行可能分配给多个窗口.<br>例如,15 分钟大小和 5 分钟滑动间隔的滑动窗口将每一行分配给 3 个不同的 15 分钟大小的窗口,以 5 分钟的间隔进行一次计算.<br>滑动窗口可以定义在事件时间/处理时间或行数上.</p>
<p>滑动窗口是通过 Slide 类定义的,具体如下,<br>over:<br>将窗口的长度定义为时间或行计数间隔.</p>
<p>every:<br>将窗口的长度定义为时间或行计数间隔.<br>滑动间隔的类型必须与窗口长度的类型相同.</p>
<p>on:<br>要对数据进行分组(时间间隔)或排序(行计数)的时间属性.<br>批处理查询支持任意 Long 或 Timestamp 类型的属性.<br>流处理查询仅支持声明的事件时间或处理时间属性.</p>
<p>as:<br>指定窗口的别名.<br>别名用于在 groupBy() 子句中引用窗口,并可以在 select() 子句中选择如窗口开始/结束或行时间戳的窗口属性.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sliding Event-time Window</span></span><br><span class="line">.window(Slide.over(lit(<span class="number">10</span>).minutes())</span><br><span class="line">          .every(lit(<span class="number">5</span>).minutes())</span><br><span class="line">          .on($(<span class="string">&quot;rowtime&quot;</span>))</span><br><span class="line">          .as(<span class="string">&quot;w&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sliding Processing-time window (assuming a processing-time attribute &quot;proctime&quot;)</span></span><br><span class="line">.window(Slide.over(lit(<span class="number">10</span>).minutes())</span><br><span class="line">          .every(lit(<span class="number">5</span>).minutes())</span><br><span class="line">          .on($(<span class="string">&quot;proctime&quot;</span>))</span><br><span class="line">          .as(<span class="string">&quot;w&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sliding Row-count window (assuming a processing-time attribute &quot;proctime&quot;)</span></span><br><span class="line">.window(Slide.over(rowInterval(<span class="number">10</span>)).every(rowInterval(<span class="number">5</span>)).on($(<span class="string">&quot;proctime&quot;</span>)).as(<span class="string">&quot;w&quot;</span>));</span><br></pre></td></tr></table></figure>

<h5 id="Session-Session-Windows"><a href="#Session-Session-Windows" class="headerlink" title="Session (Session Windows)"></a>Session (Session Windows)</h5><p>会话窗口没有固定的大小,其边界是由不活动的间隔定义的,例如,如果在定义的间隔期内没有事件出现,则会话窗口将关闭.<br>例如,定义30 分钟间隔的会话窗口,当观察到一行在 30 分钟内不活动(否则该行将被添加到现有窗口中)且30 分钟内没有添加新行,窗口会关闭.<br>会话窗口支持事件时间和处理时间.</p>
<p>会话窗口是通过 Session 类定义的,具体如下,<br>withGap:<br>将两个窗口之间的间隙定义为时间间隔.</p>
<p>on:<br>要对数据进行分组(时间间隔)或排序(行计数)的时间属性.<br>批处理查询支持任意 Long 或 Timestamp 类型的属性.<br>流处理查询仅支持声明的事件时间或处理时间属性.</p>
<p>as:<br>指定窗口的别名.<br>别名用于在 groupBy() 子句中引用窗口,并可以在 select() 子句中选择如窗口开始/结束或行时间戳的窗口属性.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Session Event-time Window</span></span><br><span class="line">.window(Session.withGap(lit(<span class="number">10</span>).minutes()).on($(<span class="string">&quot;rowtime&quot;</span>)).as(<span class="string">&quot;w&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Session Processing-time Window (assuming a processing-time attribute &quot;proctime&quot;)</span></span><br><span class="line">.window(Session.withGap(lit(<span class="number">10</span>).minutes()).on($(<span class="string">&quot;proctime&quot;</span>)).as(<span class="string">&quot;w&quot;</span>));</span><br></pre></td></tr></table></figure>

<h4 id="Over-Windows"><a href="#Over-Windows" class="headerlink" title="Over Windows"></a>Over Windows</h4><p>Over window 聚合聚合来自在标准的 SQL(OVER 子句),可以在 SELECT 查询子句中定义.<br>与在&quot;GROUP BY&quot;子句中指定的 group window 不同, over window 不会折叠行.<br>相反,over window 聚合为每个输入行在其相邻行的范围内计算聚合.</p>
<p>Over windows 使用 window(w: OverWindow*) 子句(在 Python API 中使用 over_window(*OverWindow))定义,并通过 select() 方法中的别名引用.<br>以下示例显示如何在表上定义 over window 聚合.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Table table = input</span><br><span class="line"> .window([OverWindow w].as(<span class="string">&quot;w&quot;</span>))           <span class="comment">// define over window with alias w</span></span><br><span class="line"> .select($(<span class="string">&quot;a&quot;</span>), $(<span class="string">&quot;b&quot;</span>).sum().over($(<span class="string">&quot;w&quot;</span>)), $(<span class="string">&quot;c&quot;</span>).min().over($(<span class="string">&quot;w&quot;</span>))); <span class="comment">// aggregate over the over window w</span></span><br></pre></td></tr></table></figure>

<p>OverWindow 定义了计算聚合的行范围.<br>OverWindow 不是用户可以实现的接口.<br>相反,Table API 提供了Over 类来配置 over window 的属性.<br>可以在事件时间或处理时间以及指定为时间间隔或行计数的范围内定义 over window .<br>可以通过 Over 类(和其他类)上的方法来定义 over window,具体如下:</p>
<h5 id="Partition-By"><a href="#Partition-By" class="headerlink" title="Partition By"></a>Partition By</h5><p>可选的</p>
<p>在一个或多个属性上定义输入的分区.<br>每个分区单独排序,聚合函数分别应用于每个分区.</p>
<p>注意:在流环境中,如果窗口包含 partition by 子句,则只能并行计算 over window 聚合.<br>如果没有 partitionBy(…),数据流将由单个非并行任务处理.</p>
<h5 id="Order-By-1"><a href="#Order-By-1" class="headerlink" title="Order By"></a>Order By</h5><p>必须的</p>
<p>定义每个分区内行的顺序,从而定义聚合函数应用于行的顺序.</p>
<p>注意:对于流处理查询,必须声明事件时间或处理时间属性.<br>目前,仅支持单个排序属性.</p>
<h5 id="Preceding"><a href="#Preceding" class="headerlink" title="Preceding"></a>Preceding</h5><p>可选的</p>
<p>定义了包含在窗口中并位于当前行之前的行的间隔.<br>间隔可以是时间或行计数间隔.</p>
<p>有界 over window 用间隔的大小指定,例如,时间间隔为10分钟或行计数间隔为10行.</p>
<p>无界 over window 通过常量来指定,例如,用UNBOUNDED_RANGE指定时间间隔或用 UNBOUNDED_ROW 指定行计数间隔.<br>无界 over windows 从分区的第一行开始.</p>
<p>如果省略前面的子句,则使用 UNBOUNDED_RANGE 和 CURRENT_RANGE 作为窗口前后的默认值.</p>
<h5 id="Following"><a href="#Following" class="headerlink" title="Following"></a>Following</h5><p>可选的</p>
<p>定义包含在窗口中并在当前行之后的行的窗口间隔.<br>间隔必须以与前一个间隔(时间或行计数)相同的单位指定.</p>
<p>目前,不支持在当前行之后有行的 over window.<br>相反,你可以指定两个常量之一:</p>
<p>CURRENT_ROW 将窗口的上限设置为当前行.</p>
<p>CURRENT_RANGE 将窗口的上限设置为当前行的排序键,例如,与当前行具有相同排序键的所有行都包含在窗口中.</p>
<p>如果省略后面的子句,则时间间隔窗口的上限定义为 CURRENT_RANGE,行计数间隔窗口的上限定义为CURRENT_ROW.</p>
<h5 id="As-1"><a href="#As-1" class="headerlink" title="As"></a>As</h5><p>必须的</p>
<p>为 over window 指定别名.<br>别名用于在之后的 select() 子句中引用该 over window.</p>
<p>注意:目前,同一个 select() 调用中的所有聚合函数必须在同一个 over window 上计算.</p>
<blockquote>
<p>Unbounded Over Windows</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无界的事件时间 over window(假定有一个叫&quot;rowtime&quot;的事件时间属性)</span></span><br><span class="line">.window(Over.partitionBy($(<span class="string">&quot;a&quot;</span>)).orderBy($(<span class="string">&quot;rowtime&quot;</span>)).preceding(UNBOUNDED_RANGE).as(<span class="string">&quot;w&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无界的处理时间 over window(假定有一个叫&quot;proctime&quot;的处理时间属性)</span></span><br><span class="line">.window(Over.partitionBy($(<span class="string">&quot;a&quot;</span>)).orderBy(<span class="string">&quot;proctime&quot;</span>).preceding(UNBOUNDED_RANGE).as(<span class="string">&quot;w&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无界的事件时间行数 over window(假定有一个叫&quot;rowtime&quot;的事件时间属性)</span></span><br><span class="line">.window(Over.partitionBy($(<span class="string">&quot;a&quot;</span>)).orderBy($(<span class="string">&quot;rowtime&quot;</span>)).preceding(UNBOUNDED_ROW).as(<span class="string">&quot;w&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无界的处理时间行数 over window(假定有一个叫&quot;proctime&quot;的处理时间属性)</span></span><br><span class="line">.window(Over.partitionBy($(<span class="string">&quot;a&quot;</span>)).orderBy($(<span class="string">&quot;proctime&quot;</span>)).preceding(UNBOUNDED_ROW).as(<span class="string">&quot;w&quot;</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Bounded Over Windows</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有界的事件时间 over window(假定有一个叫&quot;rowtime&quot;的事件时间属性)</span></span><br><span class="line">.window(Over.partitionBy($(<span class="string">&quot;a&quot;</span>)).orderBy($(<span class="string">&quot;rowtime&quot;</span>)).preceding(lit(<span class="number">1</span>).minutes()).as(<span class="string">&quot;w&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有界的处理时间 over window(假定有一个叫&quot;proctime&quot;的处理时间属性)</span></span><br><span class="line">.window(Over.partitionBy($(<span class="string">&quot;a&quot;</span>)).orderBy($(<span class="string">&quot;proctime&quot;</span>)).preceding(lit(<span class="number">1</span>).minutes()).as(<span class="string">&quot;w&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有界的事件时间行数 over window(假定有一个叫&quot;rowtime&quot;的事件时间属性)</span></span><br><span class="line">.window(Over.partitionBy($(<span class="string">&quot;a&quot;</span>)).orderBy($(<span class="string">&quot;rowtime&quot;</span>)).preceding(rowInterval(<span class="number">10</span>)).as(<span class="string">&quot;w&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有界的处理时间行数 over window(假定有一个叫&quot;proctime&quot;的处理时间属性)</span></span><br><span class="line">.window(Over.partitionBy($(<span class="string">&quot;a&quot;</span>)).orderBy($(<span class="string">&quot;proctime&quot;</span>)).preceding(rowInterval(<span class="number">10</span>)).as(<span class="string">&quot;w&quot;</span>));</span><br></pre></td></tr></table></figure>

<h4 id="Row-based-Operations"><a href="#Row-based-Operations" class="headerlink" title="Row-based Operations"></a>Row-based Operations</h4><p>基于行生成多列输出的操作.</p>
<h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p>Batch Streaming</p>
<p>使用用户定义的标量函数或内置标量函数执行 map 操作.<br>如果输出类型是复合类型,则输出将被展平.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMapFunction</span> <span class="keyword">extends</span> <span class="title">ScalarFunction</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Row <span class="title">eval</span><span class="params">(String a)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Row.of(a, <span class="string">&quot;pre-&quot;</span> + a);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> TypeInformation&lt;?&gt; getResultType(Class&lt;?&gt;[] signature) &#123;</span><br><span class="line">      <span class="keyword">return</span> Types.ROW(Types.STRING(), Types.STRING());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ScalarFunction func = <span class="keyword">new</span> MyMapFunction();</span><br><span class="line">tableEnv.registerFunction(<span class="string">&quot;func&quot;</span>, func);</span><br><span class="line"></span><br><span class="line">Table table = input</span><br><span class="line"> .map(call(<span class="string">&quot;func&quot;</span>, $(<span class="string">&quot;c&quot;</span>)).as(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>));</span><br></pre></td></tr></table></figure>

<h5 id="FlatMap"><a href="#FlatMap" class="headerlink" title="FlatMap"></a>FlatMap</h5><p>Batch Streaming</p>
<p>使用表函数执行 flatMap 操作.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFlatMapFunction</span> <span class="keyword">extends</span> <span class="title">TableFunction</span>&lt;<span class="title">Row</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eval</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (str.contains(<span class="string">&quot;#&quot;</span>)) &#123;</span><br><span class="line">          String[] array = str.split(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line">              collect(Row.of(array[i], array[i].length()));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TypeInformation&lt;Row&gt; <span class="title">getResultType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Types.ROW(Types.STRING(), Types.INT());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TableFunction func = <span class="keyword">new</span> MyFlatMapFunction();</span><br><span class="line">tableEnv.registerFunction(<span class="string">&quot;func&quot;</span>, func);</span><br><span class="line"></span><br><span class="line">Table table = input</span><br><span class="line"> .flatMap(call(<span class="string">&quot;func&quot;</span>, $(<span class="string">&quot;c&quot;</span>)).as(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>));</span><br></pre></td></tr></table></figure>

<h5 id="Aggregate"><a href="#Aggregate" class="headerlink" title="Aggregate"></a>Aggregate</h5><p>Batch Streaming Result</p>
<p>使用聚合函数来执行聚合操作.<br>你必须使用 select 子句关闭 aggregate,并且 select 子句不支持聚合函数.<br>如果输出类型是复合类型,则聚合的输出将被展平.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMinMaxAcc</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMinMax</span> <span class="keyword">extends</span> <span class="title">AggregateFunction</span>&lt;<span class="title">Row</span>, <span class="title">MyMinMaxAcc</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accumulate</span><span class="params">(MyMinMaxAcc acc, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (value &lt; acc.min) &#123;</span><br><span class="line">          acc.min = value;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (value &gt; acc.max) &#123;</span><br><span class="line">          acc.max = value;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MyMinMaxAcc <span class="title">createAccumulator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MyMinMaxAcc();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resetAccumulator</span><span class="params">(MyMinMaxAcc acc)</span> </span>&#123;</span><br><span class="line">      acc.min = <span class="number">0</span>;</span><br><span class="line">      acc.max = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Row <span class="title">getValue</span><span class="params">(MyMinMaxAcc acc)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Row.of(acc.min, acc.max);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TypeInformation&lt;Row&gt; <span class="title">getResultType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RowTypeInfo(Types.INT, Types.INT);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AggregateFunction myAggFunc = <span class="keyword">new</span> MyMinMax();</span><br><span class="line">tableEnv.registerFunction(<span class="string">&quot;myAggFunc&quot;</span>, myAggFunc);</span><br><span class="line">Table table = input</span><br><span class="line"> .groupBy($(<span class="string">&quot;key&quot;</span>))</span><br><span class="line"> .aggregate(call(<span class="string">&quot;myAggFunc&quot;</span>, $(<span class="string">&quot;a&quot;</span>)).as(<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>))</span><br><span class="line"> .select($(<span class="string">&quot;key&quot;</span>), $(<span class="string">&quot;x&quot;</span>), $(<span class="string">&quot;y&quot;</span>));</span><br></pre></td></tr></table></figure>

<h5 id="Group-Window-Aggregate"><a href="#Group-Window-Aggregate" class="headerlink" title="Group Window Aggregate"></a>Group Window Aggregate</h5><p>Batch Streaming</p>
<p>在 group window 和可能的一个或多个分组键上对表进行分组和聚合.<br>你必须使用 select 子句关闭 aggregate.<br>并且 select 子句不支持&quot;*&quot;或聚合函数.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AggregateFunction myAggFunc = <span class="keyword">new</span> MyMinMax();</span><br><span class="line">tableEnv.registerFunction(<span class="string">&quot;myAggFunc&quot;</span>, myAggFunc);</span><br><span class="line"></span><br><span class="line">Table table = input</span><br><span class="line">  .window(Tumble.over(lit(<span class="number">5</span>).minutes())</span><br><span class="line">                .on($(<span class="string">&quot;rowtime&quot;</span>))</span><br><span class="line">                .as(<span class="string">&quot;w&quot;</span>)) <span class="comment">// 定义窗口</span></span><br><span class="line">  .groupBy($(<span class="string">&quot;key&quot;</span>), $(<span class="string">&quot;w&quot;</span>)) <span class="comment">// 以键和窗口分组</span></span><br><span class="line">  .aggregate(call(<span class="string">&quot;myAggFunc&quot;</span>, $(<span class="string">&quot;a&quot;</span>)).as(<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>))</span><br><span class="line">  .select($(<span class="string">&quot;key&quot;</span>), $(<span class="string">&quot;x&quot;</span>), $(<span class="string">&quot;y&quot;</span>), $(<span class="string">&quot;w&quot;</span>).start(), $(<span class="string">&quot;w&quot;</span>).end()); <span class="comment">// 访问窗口属性与聚合结果</span></span><br></pre></td></tr></table></figure>

<h5 id="FlatAggregate"><a href="#FlatAggregate" class="headerlink" title="FlatAggregate"></a>FlatAggregate</h5><p>和 GroupBy Aggregation 类似.<br>使用运行中的表之后的聚合算子对分组键上的行进行分组,以按组聚合行.<br>和 AggregateFunction 的不同之处在于,TableAggregateFunction 的每个分组可能返回0或多条记录.<br>你必须使用 select 子句关闭 flatAggregate.<br>并且 select 子句不支持聚合函数.</p>
<p>除了使用 emitValue 输出结果,你还可以使用 emitUpdateWithRetract 方法.<br>和 emitValue 不同的是,emitUpdateWithRetract 用于下发已更新的值.<br>此方法在retract 模式下增量输出数据,例如,一旦有更新,我们必须在发送新的更新记录之前收回旧记录.<br>如果在表聚合函数中定义了这两个方法,则将优先使用 emitUpdateWithRetract 方法而不是 emitValue 方法,这是因为该方法可以增量输出值,因此被视为比 emitValue 方法更有效.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Top2 Accumulator.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Top2Accum</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> Integer first;</span><br><span class="line">  <span class="keyword">public</span> Integer second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 用户定义的聚合函数 top2.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Top2</span> <span class="keyword">extends</span> <span class="title">TableAggregateFunction</span>&lt;<span class="title">Tuple2</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt;, <span class="title">Top2Accum</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Top2Accum <span class="title">createAccumulator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Top2Accum acc = <span class="keyword">new</span> Top2Accum();</span><br><span class="line">      acc.first = Integer.MIN_VALUE;</span><br><span class="line">      acc.second = Integer.MIN_VALUE;</span><br><span class="line">      <span class="keyword">return</span> acc;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accumulate</span><span class="params">(Top2Accum acc, Integer v)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (v &gt; acc.first) &#123;</span><br><span class="line">          acc.second = acc.first;</span><br><span class="line">          acc.first = v;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &gt; acc.second) &#123;</span><br><span class="line">          acc.second = v;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Top2Accum acc, java.lang.Iterable&lt;Top2Accum&gt; iterable)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (Top2Accum otherAcc : iterable) &#123;</span><br><span class="line">          accumulate(acc, otherAcc.first);</span><br><span class="line">          accumulate(acc, otherAcc.second);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">emitValue</span><span class="params">(Top2Accum acc, Collector&lt;Tuple2&lt;Integer, Integer&gt;&gt; out)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 下发 value 与 rank</span></span><br><span class="line">      <span class="keyword">if</span> (acc.first != Integer.MIN_VALUE) &#123;</span><br><span class="line">          out.collect(Tuple2.of(acc.first, <span class="number">1</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (acc.second != Integer.MIN_VALUE) &#123;</span><br><span class="line">          out.collect(Tuple2.of(acc.second, <span class="number">2</span>));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tEnv.registerFunction(<span class="string">&quot;top2&quot;</span>, <span class="keyword">new</span> Top2());</span><br><span class="line">Table orders = tableEnv.from(<span class="string">&quot;Orders&quot;</span>);</span><br><span class="line">Table result = orders</span><br><span class="line">  .groupBy($(<span class="string">&quot;key&quot;</span>))</span><br><span class="line">  .flatAggregate(call(<span class="string">&quot;top2&quot;</span>, $(<span class="string">&quot;a&quot;</span>)).as(<span class="string">&quot;v&quot;</span>, <span class="string">&quot;rank&quot;</span>))</span><br><span class="line">  .select($(<span class="string">&quot;key&quot;</span>), $(<span class="string">&quot;v&quot;</span>), $(<span class="string">&quot;rank&quot;</span>));</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/flink/" rel="tag"># flink</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/08/19/flink%20datastream%20api-%E7%AE%97%E5%AD%90/" rel="prev" title="flink datastream api-算子">
                  <i class="fa fa-chevron-left"></i> flink datastream api-算子
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/08/22/flink%20sql-queries%E6%9F%A5%E8%AF%A2/" rel="next" title="flink sql-queries查询">
                  flink sql-queries查询 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">maoeryu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  






  





</body>
</html>
